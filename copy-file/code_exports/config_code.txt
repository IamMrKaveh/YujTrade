[config\logger.py] :

import sys

from loguru import logger

log_directory = "logs"
log_file = f"{log_directory}/app.log"

logger.remove()

logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
    colorize=True
)

logger.add(
    log_file,
    level="DEBUG",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} | {message}",
    rotation="10 MB",
    retention="7 days",
    encoding='utf-8',
    enqueue=True,
    backtrace=True,
    diagnose=True
)

logger.info("Logger initialized.")



=====

[config\settings.py] :

import json
from pathlib import Path
from typing import Any, Dict, Optional

from decouple import config as decouple_config

from common.constants import (
    SYMBOLS,
    TIME_FRAMES,
    AnalysisComponent,
)
from config.logger import logger
from utils.security import KeyEncryptor, get_password_from_key_manager


class SecretsManager:
    ENCRYPTION_PASSWORD = get_password_from_key_manager() or decouple_config(
        "ENCRYPTION_PASSWORD", default=None
    )

    _encryptor = None
    if ENCRYPTION_PASSWORD:
        try:
            _encryptor = KeyEncryptor(ENCRYPTION_PASSWORD)
        except Exception:
            logger.critical(
                "Failed to create encryptor. Check your ENCRYPTION_PASSWORD or key manager."
            )
            _encryptor = None

    @staticmethod
    def get_secret(key: str, cast: type = str, default: Any = None) -> Optional[Any]:
        encrypted_key = f"ENCRYPTED_{key}"
        value = decouple_config(encrypted_key, default=None)
        if value and SecretsManager._encryptor:
            decrypted = SecretsManager._encryptor.decrypt(value)
            if not decrypted:
                logger.error(f"Failed to decrypt {key}. Please re-encrypt your keys.")
                return default
            try:
                return cast(decrypted)
            except (ValueError, TypeError):
                logger.error(f"Failed to cast decrypted key {key} to {cast}.")
                return default

        return decouple_config(key, default=default, cast=cast)

    TELEGRAM_BOT_TOKEN = get_secret("TELEGRAM_BOT_TOKEN", default="")
    ADMIN_CHAT_ID = get_secret("ADMIN_CHAT_ID", default="")
    CRYPTOPANIC_KEY = get_secret("CRYPTOPANIC_KEY", default="")
    ALPHA_VANTAGE_KEY = get_secret("ALPHA_VANTAGE_KEY", default="")
    COINGECKO_KEY = get_secret("COINGECKO_KEY", default="")
    COINDESK_API_KEY = get_secret("COINDESK_API_KEY", default="")
    MESSARI_API_KEY = get_secret("MESSARI_API_KEY", default="")
    SENTRY_DSN = get_secret("SENTRY_DSN", default="")

    TF_CPP_MIN_LOG_LEVEL = decouple_config("TF_CPP_MIN_LOG_LEVEL", default="3")
    TF_ENABLE_ONEDNN_OPTS = decouple_config("TF_ENABLE_ONEDNN_OPTS", default="0")

    REDIS_HOST = decouple_config("REDIS_HOST", default=None)
    REDIS_PORT = decouple_config("REDIS_PORT", default=6379, cast=int)
    REDIS_TOKEN = decouple_config("REDIS_TOKEN", default=None)


class ConfigManager:
    DEFAULT_CONFIG = {
        "symbols": SYMBOLS,
        "timeframes": TIME_FRAMES,
        "min_confidence_score": 0,
        "signal_threshold": 50,
        "max_signals_per_timeframe": 1,
        "enable_scheduled_analysis": False,
        "schedule_hour": "*/1",
        "app_version": "5.1.0",
        "timeframe_based_weights": True,
    }

    DEFAULT_WEIGHTS_CONFIG = {
        "cache_config": {
            "default_ttl": 3600,
            "ohlcv": {"1h": 300, "4h": 900, "1d": 1800, "1w": 3600, "1M": 7200},
            "derivatives": 300,
            "macro": 86400,
            "indices": 600,
            "news": 600,
            "fundamental": 43200,
            "trending": 3600,
            "generic": 86400,
        }
    }

    def __init__(
        self,
        config_path: str = "config.json",
        weights_path: str = "indicator_weights.json",
    ):
        self.config_path = Path(config_path)
        self.weights_path = Path(weights_path)
        self.config = self._load_config()
        self.weights_config = self._load_weights_config()

    def _load_json_file(self, path: Path, default: Dict = None) -> Dict:
        if path.exists():
            try:
                with open(path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except Exception as e:
                logger.warning(f"Error loading {path}: {e}. Using defaults.")
        return default or {}

    def _load_config(self) -> Dict[str, Any]:
        loaded_config = self._load_json_file(self.config_path)
        return {**self.DEFAULT_CONFIG, **loaded_config}

    def _load_weights_config(self) -> Dict[str, Any]:
        loaded_weights = self._load_json_file(self.weights_path)
        # Deep merge with default cache config
        if "cache_config" in loaded_weights:
            for key, value in self.DEFAULT_WEIGHTS_CONFIG["cache_config"].items():
                if key not in loaded_weights["cache_config"]:
                    loaded_weights["cache_config"][key] = value
        else:
            loaded_weights["cache_config"] = self.DEFAULT_WEIGHTS_CONFIG["cache_config"]
        return loaded_weights

    def save_config(self):
        try:
            with open(self.config_path, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error saving config: {e}")

    def get(self, key: str, default=None):
        return self.config.get(key, default)

    def set(self, key: str, value):
        self.config[key] = value
        self.save_config()

    def get_component_weights(self, timeframe: str) -> Dict[str, float]:
        """Gets weights for major analysis components."""
        if self.get("timeframe_based_weights", True):
            timeframe_weights = self.weights_config.get(
                "timeframe_based_settings", {}
            ).get(timeframe, {})
            if "component_weights" in timeframe_weights:
                return timeframe_weights["component_weights"]

        return self.weights_config.get("default_settings", {}).get(
            "component_weights",
            {
                AnalysisComponent.TECHNICAL_ANALYSIS.value: 40,
                AnalysisComponent.MARKET_CONTEXT.value: 25,
                AnalysisComponent.EXTERNAL_DATA.value: 15,
                AnalysisComponent.ML_MODELS.value: 20,
            },
        )

    def get_indicator_weights(self, timeframe: str) -> Dict[str, float]:
        """Gets weights for individual indicators."""
        if self.get("timeframe_based_weights", True):
            timeframe_weights = self.weights_config.get(
                "timeframe_based_settings", {}
            ).get(timeframe, {})
            if "indicator_weights" in timeframe_weights:
                return timeframe_weights["indicator_weights"]

        return self.weights_config.get("default_settings", {}).get(
            "indicator_weights", {}
        )

    def get_cache_config(self) -> Dict[str, Any]:
        """Gets cache TTL configuration."""
        return self.weights_config.get(
            "cache_config", self.DEFAULT_WEIGHTS_CONFIG["cache_config"]
        )

    def get_cache_ttl(self, category: str, sub_category: Optional[str] = None) -> int:
        """
        Gets a specific TTL value from the cache configuration.
        e.g., get_cache_ttl('ohlcv', '1h')
        """
        cache_config = self.get_cache_config()
        category_config = cache_config.get(category)

        if isinstance(category_config, dict) and sub_category:
            return category_config.get(
                sub_category, cache_config.get("default_ttl", 3600)
            )
        elif isinstance(category_config, int):
            return category_config
        else:
            return cache_config.get("default_ttl", 3600)


=====

