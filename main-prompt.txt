این توضیح کلی پروژه تحلیل بازار کریپتو هست :

شروع
  ↓
بارگذاری تنظیمات
  ↓
راه‌اندازی ربات تلگرام
  ↓
برای هر تایم فریم:
  ↓
  دریافت کندل‌های 60 ارز از کوینکس
  ↓
  محاسبه اندیکاتورها برای هر ارز
  ↓
  تحلیل و تولید سیگنال‌ها
  ↓
  محاسبه Stop Loss و Take Profit
  ↓
  ارسال پیام به کاربران تلگرام
  ↓
پایان

===========

این ساختار پوشه بندی پروژه هست:

YUJTRADE/
├── main.py                 # نقطه ورود اصلی
├── config/
│   ├── settings.py         # تنظیمات و کانفیگ
│   └── constants.py        # ثابت‌ها (تایم فریم‌ها، ارزها)
├── services/
│   ├── coinex_api.py       # سرویس API کوینکس
│   ├── indicator_service.py # محاسبات اندیکاتورها
│   ├── signal_service.py   # تولید سیگنال
│   └── telegram_service.py # ارسال پیام تلگرام
├── models/
│   ├── base.py             # مدل پایه
│   ├── candle.py          # مدل کندل
│   ├── indicators.py       # مدل اندیکاتورها
│   ├── market.py           # مدل بازار
│   ├── notification.py     # مدل نوتیفیکیشن
│   ├── signal.py          # مدل سیگنال
│   ├── strategy.py         # مدل استراتژی
│   └── timeframe.py       # مدل تایم فریم
│   └── user.py              # مدل کاربر
├── utils/
│   ├── helpers.py         # توابع کمکی
│   └── validators.py      # اعتبارسنجی داده‌ها
├── handlers/
│   └── bot_handlers.py    # هندلرهای ربات تلگرام
├── requirements.txt
├── symbols.txt
└── logger_config.txt

==========

کد پایتون فایل زیر را بر اساس مدل های پروژه باید بنویسی :

main.py
config/settings.py
config/constants.py
handlers/bot_handlers.py
services/coinex_api.py
services/indicator_service.py
services/signal_service.py
services/telegram_service.py
utils/helpers.py
utils/validators.py

اصول clean code و clean architecture را رعایت کن.

کد های تولید شده باید مقیاس پذیری بالایی داشته باشد!





مدل های پیش نیاز پروژه را در متن زیر برات فرستادم :

==========

# models/base.py

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, TypeVar, Generic, Type, Union
from datetime import datetime, timezone
from dataclasses import dataclass, field
from decimal import Decimal, ROUND_HALF_UP
import json
import uuid
import hashlib
from enum import Enum

T = TypeVar('T', bound='BaseModel')

class ValidationError(Exception):
    """خطای اعتبارسنجی مدل"""
    pass

class ModelStatus(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    ARCHIVED = "archived"

@dataclass
class BaseModel(ABC):
    """کلاس پایه برای همه مدل‌ها با قابلیت‌های پیشرفته"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    status: ModelStatus = ModelStatus.ACTIVE
    version: int = 1
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """اعتبارسنجی پس از ایجاد"""
        self.validate()
    
    @abstractmethod
    def validate(self) -> None:
        """اعتبارسنجی مدل"""
        if not self.id:
            raise ValidationError("ID نمی‌تواند خالی باشد")
    
    def to_dict(self, exclude_fields: Optional[List[str]] = None) -> Dict[str, Any]:
        """تبدیل مدل به dictionary با قابلیت حذف فیلدها"""
        exclude_fields = exclude_fields or []
        result = {}
        
        for key, value in self.__dict__.items():
            if key in exclude_fields:
                continue
                
            if isinstance(value, datetime):
                result[key] = value.isoformat()
            elif isinstance(value, Decimal):
                result[key] = str(value)
            elif isinstance(value, BaseModel):
                result[key] = value.to_dict()
            elif isinstance(value, list) and value and isinstance(value[0], BaseModel):
                result[key] = [item.to_dict() for item in value]
            elif isinstance(value, Enum):
                result[key] = value.value
            elif isinstance(value, set):
                result[key] = list(value)
            else:
                result[key] = value
        return result
    
    def to_json(self, **kwargs) -> str:
        """تبدیل مدل به JSON"""
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2, **kwargs)
    
    @classmethod
    @abstractmethod
    def from_dict(cls: Type[T], data: Dict[str, Any]) -> T:
        """ساخت مدل از dictionary"""
        pass
    
    def update_timestamp(self):
        """به‌روزرسانی زمان تغییر و نسخه"""
        self.updated_at = datetime.now(timezone.utc)
        self.version += 1
    
    def clone(self: T) -> T:
        """کلون کردن مدل با ID جدید"""
        data = self.to_dict(exclude_fields=['id', 'created_at', 'updated_at'])
        return self.__class__.from_dict(data)
    
    def get_hash(self) -> str:
        """محاسبه hash مدل"""
        data = self.to_dict(exclude_fields=['id', 'created_at', 'updated_at', 'version'])
        return hashlib.md5(json.dumps(data, sort_keys=True).encode()).hexdigest()
    
    def add_metadata(self, key: str, value: Any):
        """افزودن metadata"""
        self.metadata[key] = value
        self.update_timestamp()
    
    def get_metadata(self, key: str, default=None):
        """دریافت metadata"""
        return self.metadata.get(key, default)

@dataclass
class ModelValidator:
    """اعتبارسنج عمومی برای مدل‌ها"""
    
    @staticmethod
    def validate_decimal(value: Any, min_value: Optional[Decimal] = None, 
                        max_value: Optional[Decimal] = None) -> Decimal:
        """اعتبارسنجی مقدار decimal"""
        if value is None:
            raise ValidationError("مقدار نمی‌تواند None باشد")
        
        try:
            decimal_value = Decimal(str(value))
        except:
            raise ValidationError(f"مقدار {value} معتبر نیست")
        
        if min_value is not None and decimal_value < min_value:
            raise ValidationError(f"مقدار نباید کمتر از {min_value} باشد")
        
        if max_value is not None and decimal_value > max_value:
            raise ValidationError(f"مقدار نباید بیشتر از {max_value} باشد")
        
        return decimal_value
    
    @staticmethod
    def validate_string(value: str, min_length: int = 1, max_length: int = 255) -> str:
        """اعتبارسنجی رشته"""
        if not isinstance(value, str):
            raise ValidationError("مقدار باید رشته باشد")
        
        if len(value) < min_length:
            raise ValidationError(f"طول رشته نباید کمتر از {min_length} باشد")
        
        if len(value) > max_length:
            raise ValidationError(f"طول رشته نباید بیشتر از {max_length} باشد")
        
        return value.strip()
    
    @staticmethod
    def validate_percentage(value: float) -> float:
        """اعتبارسنجی درصد (0-100)"""
        if not 0 <= value <= 100:
            raise ValidationError("درصد باید بین 0 و 100 باشد")
        return value

class ModelRepository(Generic[T]):
    """Repository pattern برای مدیریت مدل‌ها"""
    
    def __init__(self, model_class: Type[T]):
        self.model_class = model_class
        self._storage: Dict[str, T] = {}
    
    def save(self, model: T) -> T:
        """ذخیره مدل"""
        model.update_timestamp()
        self._storage[model.id] = model
        return model
    
    def find_by_id(self, model_id: str) -> Optional[T]:
        """جستجو بر اساس ID"""
        return self._storage.get(model_id)
    
    def find_all(self, status: Optional[ModelStatus] = None) -> List[T]:
        """دریافت همه مدل‌ها"""
        if status is None:
            return list(self._storage.values())
        return [m for m in self._storage.values() if m.status == status]
    
    def delete(self, model_id: str) -> bool:
        """حذف مدل"""
        if model_id in self._storage:
            del self._storage[model_id]
            return True
        return False
    
    def count(self) -> int:
        """تعداد مدل‌ها"""
        return len(self._storage)



# models/candle.py

# models/candle.py
from dataclasses import dataclass
from typing import List, Dict, Any, Optional, Tuple
from decimal import Decimal
from datetime import datetime, timedelta
from enum import Enum
from .base import BaseModel, ModelValidator

class CandlePatternType(Enum):
    """انواع الگوی کندل"""
    DOJI = "doji"
    HAMMER = "hammer"
    HANGING_MAN = "hanging_man"
    SHOOTING_STAR = "shooting_star"
    ENGULFING_BULLISH = "engulfing_bullish"
    ENGULFING_BEARISH = "engulfing_bearish"
    MORNING_STAR = "morning_star"
    EVENING_STAR = "evening_star"

@dataclass
class CandlePattern(BaseModel):
    """الگوی کندل شناسایی شده"""
    type: CandlePatternType
    candle_indices: List[int]  # اندیس کندل‌های دخیل در الگو
    confidence: float  # اطمینان از الگو 0-1
    bullish: bool  # آیا الگو صعودی است؟
    description: str
    
    def validate(self):
        super().validate()
        if not 0 <= self.confidence <= 1:
            raise ValidationError("اطمینان باید بین 0 و 1 باشد")
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CandlePattern':
        return cls(
            type=CandlePatternType(data['type']),
            candle_indices=data['candle_indices'],
            confidence=data['confidence'],
            bullish=data['bullish'],
            description=data['description']
        )

@dataclass
class Candle(BaseModel):
    """مدل کندل OHLCV با قابلیت‌های پیشرفته"""
    symbol: str
    timeframe: str
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    quote_volume: Optional[Decimal] = None  # حجم quote
    trade_count: Optional[int] = None  # تعداد معامله
    taker_buy_volume: Optional[Decimal] = None  # حجم خرید taker
    
    def validate(self):
        super().validate()
        ModelValidator.validate_string(self.symbol, min_length=3, max_length=20)
        ModelValidator.validate_string(self.timeframe, min_length=2, max_length=5)
        
        # اعتبارسنجی قیمت‌ها
        for price_field in ['open', 'high', 'low', 'close']:
            price = getattr(self, price_field)
            ModelValidator.validate_decimal(price, min_value=Decimal('0'))
        
        # بررسی منطقی قیمت‌ها
        if not (self.low <= self.open <= self.high and self.low <= self.close <= self.high):
            raise ValidationError("قیمت‌های OHLC منطقی نیستند")
        
        ModelValidator.validate_decimal(self.volume, min_value=Decimal('0'))
    
    @property
    def is_green(self) -> bool:
        return self.close > self.open
    
    @property
    def is_red(self) -> bool:
        return self.close < self.open
    
    @property
    def is_doji(self) -> bool:
        """آیا کندل دوجی است؟"""
        body_size = abs(self.close - self.open)
        total_range = self.high - self.low
        return body_size / total_range < 0.1 if total_range > 0 else False
    
    @property
    def body_size(self) -> Decimal:
        return abs(self.close - self.open)
    
    @property
    def upper_shadow(self) -> Decimal:
        return self.high - max(self.open, self.close)
    
    @property
    def lower_shadow(self) -> Decimal:
        return min(self.open, self.close) - self.low
    
    @property
    def total_range(self) -> Decimal:
        return self.high - self.low
    
    @property
    def price_change(self) -> Decimal:
        return self.close - self.open
    
    @property
    def price_change_percent(self) -> float:
        if self.open == 0:
            return 0
        return float((self.close - self.open) / self.open * 100)
    
    @property
    def typical_price(self) -> Decimal:
        """قیمت معمول (HLC/3)"""
        return (self.high + self.low + self.close) / 3
    
    @property
    def weighted_price(self) -> Decimal:
        """قیمت وزنی (OHLC/4)"""
        return (self.open + self.high + self.low + self.close) / 4
    
    def get_volatility(self) -> float:
        """محاسبه نوسان کندل"""
        if self.typical_price == 0:
            return 0
        return float(self.total_range / self.typical_price * 100)
    
    def is_gap_up(self, previous_candle: 'Candle') -> bool:
        """آیا gap صعودی دارد؟"""
        return self.low > previous_candle.high
    
    def is_gap_down(self, previous_candle: 'Candle') -> bool:
        """آیا gap نزولی دارد؟"""
        return self.high < previous_candle.low
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Candle':
        return cls(
            symbol=data['symbol'],
            timeframe=data['timeframe'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            open=Decimal(str(data['open'])),
            high=Decimal(str(data['high'])),
            low=Decimal(str(data['low'])),
            close=Decimal(str(data['close'])),
            volume=Decimal(str(data['volume'])),
            quote_volume=Decimal(str(data['quote_volume'])) if data.get('quote_volume') else None,
            trade_count=data.get('trade_count'),
            taker_buy_volume=Decimal(str(data['taker_buy_volume'])) if data.get('taker_buy_volume') else None
        )

@dataclass
class CandleCollection(BaseModel):
    """مجموعه کندل‌ها با قابلیت‌های تحلیلی پیشرفته"""
    symbol: str
    timeframe: str
    candles: List[Candle]
    last_update: datetime
    is_complete: bool = True  # آیا داده‌ها کامل هستند؟
    patterns: List[CandlePattern] = field(default_factory=list)
    
    def validate(self):
        super().validate()
        ModelValidator.validate_string(self.symbol, min_length=3, max_length=20)
        ModelValidator.validate_string(self.timeframe, min_length=2, max_length=5)
        
        if not self.candles:
            raise ValidationError("حداقل یک کندل باید وجود داشته باشد")
        
        # بررسی ترتیب زمانی
        for i in range(1, len(self.candles)):
            if self.candles[i].timestamp <= self.candles[i-1].timestamp:
                raise ValidationError("کندل‌ها باید به ترتیب زمانی باشند")
    
    @property
    def latest_candle(self) -> Optional[Candle]:
        return self.candles[-1] if self.candles else None
    
    @property
    def oldest_candle(self) -> Optional[Candle]:
        return self.candles[0] if self.candles else None
    
    @property
    def count(self) -> int:
        return len(self.candles)
    
    @property
    def time_span(self) -> Optional[timedelta]:
        """بازه زمانی کل"""
        if len(self.candles) < 2:
            return None
        return self.latest_candle.timestamp - self.oldest_candle.timestamp
    
    def get_closes(self) -> List[Decimal]:
        return [candle.close for candle in self.candles]
    
    def get_highs(self) -> List[Decimal]:
        return [candle.high for candle in self.candles]
    
    def get_lows(self) -> List[Decimal]:
        return [candle.low for candle in self.candles]
    
    def get_opens(self) -> List[Decimal]:
        return [candle.open for candle in self.candles]
    
    def get_volumes(self) -> List[Decimal]:
        return [candle.volume for candle in self.candles]
    
    def get_typical_prices(self) -> List[Decimal]:
        return [candle.typical_price for candle in self.candles]
    
    def get_price_range(self) -> Tuple[Decimal, Decimal]:
        """محدوده قیمت (کمینه، بیشینه)"""
        if not self.candles:
            return Decimal('0'), Decimal('0')
        
        all_highs = self.get_highs()
        all_lows = self.get_lows()
        return min(all_lows), max(all_highs)
    
    def get_volume_stats(self) -> Dict[str, Decimal]:
        """آمار حجم معاملات"""
        volumes = self.get_volumes()
        if not volumes:
            return {}
        
        return {
            'total': sum(volumes),
            'average': sum(volumes) / len(volumes),
            'max': max(volumes),
            'min': min(volumes)
        }
    
    def get_price_change_percent(self) -> float:
        """درصد تغییر قیمت کل دوره"""
        if len(self.candles) < 2:
            return 0
        
        first_price = self.candles[0].open
        last_price = self.candles[-1].close
        
        if first_price == 0:
            return 0
        
        return float((last_price - first_price) / first_price * 100)
    
    def get_volatility_average(self) -> float:
        """میانگین نوسان"""
        if not self.candles:
            return 0
        
        volatilities = [candle.get_volatility() for candle in self.candles]
        return sum(volatilities) / len(volatilities)
    
    def get_green_red_ratio(self) -> Tuple[int, int]:
        """نسبت کندل‌های سبز به قرمز"""
        green_count = sum(1 for candle in self.candles if candle.is_green)
        red_count = len(self.candles) - green_count
        return green_count, red_count
    
    def slice_by_time(self, start_time: datetime, end_time: datetime) -> 'CandleCollection':
        """برش بر اساس زمان"""
        filtered_candles = [
            candle for candle in self.candles
            if start_time <= candle.timestamp <= end_time
        ]
        
        return CandleCollection(
            symbol=self.symbol,
            timeframe=self.timeframe,
            candles=filtered_candles,
            last_update=self.last_update,
            is_complete=False
        )
    
    def slice_by_count(self, count: int, from_end: bool = True) -> 'CandleCollection':
        """برش بر اساس تعداد"""
        if from_end:
            selected_candles = self.candles[-count:] if count < len(self.candles) else self.candles
        else:
            selected_candles = self.candles[:count]
        
        return CandleCollection(
            symbol=self.symbol,
            timeframe=self.timeframe,
            candles=selected_candles,
            last_update=self.last_update,
            is_complete=False
        )
    
    def detect_patterns(self) -> List[CandlePattern]:
        """شناسایی الگوهای کندل"""
        patterns = []
        
        for i in range(len(self.candles)):
            candle = self.candles[i]
            
            # شناسایی Doji
            if candle.is_doji:
                patterns.append(CandlePattern(
                    type=CandlePatternType.DOJI,
                    candle_indices=[i],
                    confidence=0.8,
                    bullish=False,  # خنثی
                    description="الگوی Doji - تردید در بازار"
                ))
            
            # شناسایی Hammer (نیاز به کندل قبلی برای تأیید)
            if i > 0:
                prev_candle = self.candles[i-1]
                if (candle.lower_shadow > candle.body_size * 2 and
                    candle.upper_shadow < candle.body_size * 0.1 and
                    prev_candle.is_red):
                    patterns.append(CandlePattern(
                        type=CandlePatternType.HAMMER,
                        candle_indices=[i-1, i],
                        confidence=0.7,
                        bullish=True,
                        description="الگوی Hammer - احتمال برگشت صعودی"
                    ))
        
        self.patterns = patterns
        return patterns
    
    def add_candle(self, candle: Candle):
        """افزودن کندل جدید"""
        if candle.symbol != self.symbol or candle.timeframe != self.timeframe:
            raise ValidationError("ارز یا تایم فریم کندل مطابقت ندارد")
        
        # حفظ ترتیب زمانی
        inserted = False
        for i, existing_candle in enumerate(self.candles):
            if candle.timestamp < existing_candle.timestamp:
                self.candles.insert(i, candle)
                inserted = True
                break
            elif candle.timestamp == existing_candle.timestamp:
                # جایگزینی کندل موجود
                self.candles[i] = candle
                inserted = True
                break
        
        if not inserted:
            self.candles.append(candle)
        
        self.last_update = datetime.now()
        self.update_timestamp()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CandleCollection':
        candles = [Candle.from_dict(c) for c in data['candles']]
        patterns = [CandlePattern.from_dict(p) for p in data.get('patterns', [])]
        
        return cls(
            symbol=data['symbol'],
            timeframe=data['timeframe'],
            candles=candles,
            last_update=datetime.fromisoformat(data['last_update']),
            is_complete=data.get('is_complete', True),
            patterns=patterns
        )



# models/indicators.py

from dataclasses import dataclass
from typing import Dict, Any, Optional, Union
from decimal import Decimal
from enum import Enum
from .base import BaseModel

class IndicatorType(Enum):
    """انواع اندیکاتور"""
    RSI = "rsi"
    MACD = "macd"
    BOLLINGER_BANDS = "bollinger_bands"
    SMA = "sma"
    EMA = "ema"
    STOCHASTIC = "stochastic"
    ADX = "adx"
    VOLUME_PROFILE = "volume_profile"

@dataclass
class IndicatorResult(BaseModel):
    """نتیجه محاسبه اندیکاتور"""
    type: IndicatorType
    symbol: str
    timeframe: str
    value: Union[Decimal, Dict[str, Decimal]]  # مقدار یا دیکشنری مقادیر
    signal: Optional[str] = None  # "buy", "sell", "neutral"
    strength: float = 0.0  # قدرت سیگنال 0-1
    confidence: float = 0.0  # اطمینان از سیگنال 0-1
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'IndicatorResult':
        value = data['value']
        if isinstance(value, dict):
            value = {k: Decimal(str(v)) for k, v in value.items()}
        else:
            value = Decimal(str(value))
            
        return cls(
            type=IndicatorType(data['type']),
            symbol=data['symbol'],
            timeframe=data['timeframe'],
            value=value,
            signal=data.get('signal'),
            strength=data.get('strength', 0.0),
            confidence=data.get('confidence', 0.0)
        )



# models/market.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List
from enum import Enum
from decimal import Decimal
from datetime import datetime, timedelta
from .base import BaseModel

class MarketCondition(Enum):
    """وضعیت بازار"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    SIDEWAYS = "sideways"
    VOLATILE = "volatile"
    CALM = "calm"
    EXTREMELY_BULLISH = "extremely_bullish"
    EXTREMELY_BEARISH = "extremely_bearish"

class TrendDirection(Enum):
    """جهت روند"""
    UP = "up"
    DOWN = "down"
    NEUTRAL = "neutral"

class MarketPhase(Enum):
    """فاز بازار"""
    ACCUMULATION = "accumulation"
    MARKUP = "markup"
    DISTRIBUTION = "distribution"
    DECLINE = "decline"

class VolumeProfile(Enum):
    """پروفایل حجم معاملات"""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    EXTREMELY_HIGH = "extremely_high"

@dataclass
class MarketIndicators:
    """اندیکاتورهای تکنیکال بازار"""
    rsi: Optional[float] = None
    macd_signal: Optional[str] = None
    moving_average_50: Optional[Decimal] = None
    moving_average_200: Optional[Decimal] = None
    bollinger_upper: Optional[Decimal] = None
    bollinger_lower: Optional[Decimal] = None
    support_level: Optional[Decimal] = None
    resistance_level: Optional[Decimal] = None
    fibonacci_levels: List[Decimal] = field(default_factory=list)

@dataclass
class MarketSentiment:
    """احساسات بازار"""
    fear_greed_index: Optional[int] = None
    social_sentiment_score: Optional[float] = None
    news_sentiment: Optional[str] = None
    whale_activity: Optional[str] = None
    institutional_flow: Optional[str] = None
    retail_sentiment: Optional[str] = None

@dataclass
class VolumeAnalysis:
    """تحلیل حجم معاملات"""
    total_volume_24h: Optional[Decimal] = None
    volume_change_24h: Optional[float] = None
    volume_profile: VolumeProfile = VolumeProfile.NORMAL
    top_volume_pairs: List[str] = field(default_factory=list)
    volume_weighted_price: Optional[Decimal] = None

@dataclass
class MarketCorrelations:
    """همبستگی‌های بازار"""
    btc_correlation: Optional[float] = None
    eth_correlation: Optional[float] = None
    traditional_markets_correlation: Optional[float] = None
    gold_correlation: Optional[float] = None
    dollar_index_correlation: Optional[float] = None

@dataclass
class MarketMetrics:
    """متریک‌های پیشرفته بازار"""
    market_cap_to_realized_value: Optional[float] = None
    network_value_to_transactions: Optional[float] = None
    realized_volatility: Optional[float] = None
    implied_volatility: Optional[float] = None
    funding_rates_average: Optional[float] = None
    open_interest: Optional[Decimal] = None
    long_short_ratio: Optional[float] = None

@dataclass
class MarketData(BaseModel):
    """داده‌های کلی بازار"""
    # اطلاعات اصلی
    total_market_cap: Optional[Decimal] = None
    total_volume_24h: Optional[Decimal] = None
    btc_dominance: Optional[float] = None
    eth_dominance: Optional[float] = None
    altcoin_market_cap: Optional[Decimal] = None
    
    # وضعیت و روند
    condition: MarketCondition = MarketCondition.SIDEWAYS
    trend_direction: TrendDirection = TrendDirection.NEUTRAL
    market_phase: MarketPhase = MarketPhase.ACCUMULATION
    volatility_score: float = 0.0
    trend_strength: float = 0.0
    
    # تغییرات درصدی
    market_cap_change_24h: Optional[float] = None
    market_cap_change_7d: Optional[float] = None
    market_cap_change_30d: Optional[float] = None
    
    # اندیکاتورها و احساسات
    indicators: MarketIndicators = field(default_factory=MarketIndicators)
    sentiment: MarketSentiment = field(default_factory=MarketSentiment)
    volume_analysis: VolumeAnalysis = field(default_factory=VolumeAnalysis)
    correlations: MarketCorrelations = field(default_factory=MarketCorrelations)
    metrics: MarketMetrics = field(default_factory=MarketMetrics)
    
    # اطلاعات زمانی
    timestamp: datetime = field(default_factory=datetime.now)
    last_updated: Optional[datetime] = None
    data_freshness_minutes: int = 0
    
    # آمار بازار
    active_cryptocurrencies: Optional[int] = None
    active_markets: Optional[int] = None
    top_gainers: List[str] = field(default_factory=list)
    top_losers: List[str] = field(default_factory=list)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'MarketData':
        """ایجاد نمونه از دیکشنری"""
        indicators_data = data.get('indicators', {})
        sentiment_data = data.get('sentiment', {})
        volume_data = data.get('volume_analysis', {})
        correlations_data = data.get('correlations', {})
        metrics_data = data.get('metrics', {})
        
        return cls(
            # اطلاعات اصلی
            total_market_cap=Decimal(str(data['total_market_cap'])) if data.get('total_market_cap') else None,
            total_volume_24h=Decimal(str(data['total_volume_24h'])) if data.get('total_volume_24h') else None,
            btc_dominance=data.get('btc_dominance'),
            eth_dominance=data.get('eth_dominance'),
            altcoin_market_cap=Decimal(str(data['altcoin_market_cap'])) if data.get('altcoin_market_cap') else None,
            
            # وضعیت و روند
            condition=MarketCondition(data.get('condition', 'sideways')),
            trend_direction=TrendDirection(data.get('trend_direction', 'neutral')),
            market_phase=MarketPhase(data.get('market_phase', 'accumulation')),
            volatility_score=data.get('volatility_score', 0.0),
            trend_strength=data.get('trend_strength', 0.0),
            
            # تغییرات درصدی
            market_cap_change_24h=data.get('market_cap_change_24h'),
            market_cap_change_7d=data.get('market_cap_change_7d'),
            market_cap_change_30d=data.get('market_cap_change_30d'),
            
            # اندیکاتورها
            indicators=MarketIndicators(
                rsi=indicators_data.get('rsi'),
                macd_signal=indicators_data.get('macd_signal'),
                moving_average_50=Decimal(str(indicators_data['moving_average_50'])) if indicators_data.get('moving_average_50') else None,
                moving_average_200=Decimal(str(indicators_data['moving_average_200'])) if indicators_data.get('moving_average_200') else None,
                bollinger_upper=Decimal(str(indicators_data['bollinger_upper'])) if indicators_data.get('bollinger_upper') else None,
                bollinger_lower=Decimal(str(indicators_data['bollinger_lower'])) if indicators_data.get('bollinger_lower') else None,
                support_level=Decimal(str(indicators_data['support_level'])) if indicators_data.get('support_level') else None,
                resistance_level=Decimal(str(indicators_data['resistance_level'])) if indicators_data.get('resistance_level') else None,
                fibonacci_levels=[Decimal(str(level)) for level in indicators_data.get('fibonacci_levels', [])]
            ),
            
            # احساسات
            sentiment=MarketSentiment(
                fear_greed_index=sentiment_data.get('fear_greed_index'),
                social_sentiment_score=sentiment_data.get('social_sentiment_score'),
                news_sentiment=sentiment_data.get('news_sentiment'),
                whale_activity=sentiment_data.get('whale_activity'),
                institutional_flow=sentiment_data.get('institutional_flow'),
                retail_sentiment=sentiment_data.get('retail_sentiment')
            ),
            
            # تحلیل حجم
            volume_analysis=VolumeAnalysis(
                total_volume_24h=Decimal(str(volume_data['total_volume_24h'])) if volume_data.get('total_volume_24h') else None,
                volume_change_24h=volume_data.get('volume_change_24h'),
                volume_profile=VolumeProfile(volume_data.get('volume_profile', 'normal')),
                top_volume_pairs=volume_data.get('top_volume_pairs', []),
                volume_weighted_price=Decimal(str(volume_data['volume_weighted_price'])) if volume_data.get('volume_weighted_price') else None
            ),
            
            # همبستگی‌ها
            correlations=MarketCorrelations(
                btc_correlation=correlations_data.get('btc_correlation'),
                eth_correlation=correlations_data.get('eth_correlation'),
                traditional_markets_correlation=correlations_data.get('traditional_markets_correlation'),
                gold_correlation=correlations_data.get('gold_correlation'),
                dollar_index_correlation=correlations_data.get('dollar_index_correlation')
            ),
            
            # متریک‌های پیشرفته
            metrics=MarketMetrics(
                market_cap_to_realized_value=metrics_data.get('market_cap_to_realized_value'),
                network_value_to_transactions=metrics_data.get('network_value_to_transactions'),
                realized_volatility=metrics_data.get('realized_volatility'),
                implied_volatility=metrics_data.get('implied_volatility'),
                funding_rates_average=metrics_data.get('funding_rates_average'),
                open_interest=Decimal(str(metrics_data['open_interest'])) if metrics_data.get('open_interest') else None,
                long_short_ratio=metrics_data.get('long_short_ratio')
            ),
            
            # اطلاعات زمانی
            timestamp=datetime.fromisoformat(data['timestamp']) if data.get('timestamp') else datetime.now(),
            last_updated=datetime.fromisoformat(data['last_updated']) if data.get('last_updated') else None,
            data_freshness_minutes=data.get('data_freshness_minutes', 0),
            
            # آمار بازار
            active_cryptocurrencies=data.get('active_cryptocurrencies'),
            active_markets=data.get('active_markets'),
            top_gainers=data.get('top_gainers', []),
            top_losers=data.get('top_losers', [])
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """تبدیل به دیکشنری"""
        return {
            # اطلاعات اصلی
            'total_market_cap': str(self.total_market_cap) if self.total_market_cap else None,
            'total_volume_24h': str(self.total_volume_24h) if self.total_volume_24h else None,
            'btc_dominance': self.btc_dominance,
            'eth_dominance': self.eth_dominance,
            'altcoin_market_cap': str(self.altcoin_market_cap) if self.altcoin_market_cap else None,
            
            # وضعیت و روند
            'condition': self.condition.value,
            'trend_direction': self.trend_direction.value,
            'market_phase': self.market_phase.value,
            'volatility_score': self.volatility_score,
            'trend_strength': self.trend_strength,
            
            # تغییرات درصدی
            'market_cap_change_24h': self.market_cap_change_24h,
            'market_cap_change_7d': self.market_cap_change_7d,
            'market_cap_change_30d': self.market_cap_change_30d,
            
            # اندیکاتورها
            'indicators': {
                'rsi': self.indicators.rsi,
                'macd_signal': self.indicators.macd_signal,
                'moving_average_50': str(self.indicators.moving_average_50) if self.indicators.moving_average_50 else None,
                'moving_average_200': str(self.indicators.moving_average_200) if self.indicators.moving_average_200 else None,
                'bollinger_upper': str(self.indicators.bollinger_upper) if self.indicators.bollinger_upper else None,
                'bollinger_lower': str(self.indicators.bollinger_lower) if self.indicators.bollinger_lower else None,
                'support_level': str(self.indicators.support_level) if self.indicators.support_level else None,
                'resistance_level': str(self.indicators.resistance_level) if self.indicators.resistance_level else None,
                'fibonacci_levels': [str(level) for level in self.indicators.fibonacci_levels]
            },
            
            # احساسات
            'sentiment': {
                'fear_greed_index': self.sentiment.fear_greed_index,
                'social_sentiment_score': self.sentiment.social_sentiment_score,
                'news_sentiment': self.sentiment.news_sentiment,
                'whale_activity': self.sentiment.whale_activity,
                'institutional_flow': self.sentiment.institutional_flow,
                'retail_sentiment': self.sentiment.retail_sentiment
            },
            
            # تحلیل حجم
            'volume_analysis': {
                'total_volume_24h': str(self.volume_analysis.total_volume_24h) if self.volume_analysis.total_volume_24h else None,
                'volume_change_24h': self.volume_analysis.volume_change_24h,
                'volume_profile': self.volume_analysis.volume_profile.value,
                'top_volume_pairs': self.volume_analysis.top_volume_pairs,
                'volume_weighted_price': str(self.volume_analysis.volume_weighted_price) if self.volume_analysis.volume_weighted_price else None
            },
            
            # همبستگی‌ها
            'correlations': {
                'btc_correlation': self.correlations.btc_correlation,
                'eth_correlation': self.correlations.eth_correlation,
                'traditional_markets_correlation': self.correlations.traditional_markets_correlation,
                'gold_correlation': self.correlations.gold_correlation,
                'dollar_index_correlation': self.correlations.dollar_index_correlation
            },
            
            # متریک‌های پیشرفته
            'metrics': {
                'market_cap_to_realized_value': self.metrics.market_cap_to_realized_value,
                'network_value_to_transactions': self.metrics.network_value_to_transactions,
                'realized_volatility': self.metrics.realized_volatility,
                'implied_volatility': self.metrics.implied_volatility,
                'funding_rates_average': self.metrics.funding_rates_average,
                'open_interest': str(self.metrics.open_interest) if self.metrics.open_interest else None,
                'long_short_ratio': self.metrics.long_short_ratio
            },
            
            # اطلاعات زمانی
            'timestamp': self.timestamp.isoformat(),
            'last_updated': self.last_updated.isoformat() if self.last_updated else None,
            'data_freshness_minutes': self.data_freshness_minutes,
            
            # آمار بازار
            'active_cryptocurrencies': self.active_cryptocurrencies,
            'active_markets': self.active_markets,
            'top_gainers': self.top_gainers,
            'top_losers': self.top_losers
        }
    
    def is_bullish(self) -> bool:
        """بررسی صعودی بودن بازار"""
        return self.condition in [MarketCondition.BULLISH, MarketCondition.EXTREMELY_BULLISH]
    
    def is_bearish(self) -> bool:
        """بررسی نزولی بودن بازار"""
        return self.condition in [MarketCondition.BEARISH, MarketCondition.EXTREMELY_BEARISH]
    
    def is_volatile(self) -> bool:
        """بررسی پرنوسان بودن بازار"""
        return self.condition == MarketCondition.VOLATILE or self.volatility_score > 70
    
    def get_market_summary(self) -> str:
        """خلاصه وضعیت بازار"""
        summary = f"Market Cap: ${self.total_market_cap:,.0f}" if self.total_market_cap else "Market Cap: N/A"
        summary += f"\nBTC Dominance: {self.btc_dominance:.1f}%" if self.btc_dominance else "\nBTC Dominance: N/A"
        summary += f"\nCondition: {self.condition.value.title()}"
        summary += f"\nTrend: {self.trend_direction.value.title()}"
        summary += f"\nVolatility: {self.volatility_score:.1f}/100"
        
        if self.sentiment.fear_greed_index:
            summary += f"\nFear & Greed: {self.sentiment.fear_greed_index}/100"
        
        return summary
    
    def is_data_fresh(self, max_age_minutes: int = 15) -> bool:
        """بررسی تازگی داده‌ها"""
        return self.data_freshness_minutes <= max_age_minutes
    
    def get_dominant_trend(self) -> str:
        """تعیین روند غالب"""
        if self.trend_strength > 70:
            return f"Strong {self.trend_direction.value.title()}"
        elif self.trend_strength > 40:
            return f"Moderate {self.trend_direction.value.title()}"
        else:
            return "Weak/Sideways"
    
    def calculate_market_health_score(self) -> float:
        """محاسبه امتیاز سلامت بازار"""
        score = 50.0  # نقطه شروع
        
        # بر اساس احساسات
        if self.sentiment.fear_greed_index:
            if 40 <= self.sentiment.fear_greed_index <= 60:
                score += 10  # تعادل خوب
            elif self.sentiment.fear_greed_index < 20 or self.sentiment.fear_greed_index > 80:
                score -= 15  # افراط
        
        # بر اساس نوسانات
        if self.volatility_score < 30:
            score += 10  # نوسانات کم
        elif self.volatility_score > 70:
            score -= 10  # نوسانات زیاد
        
        # بر اساس حجم معاملات
        if self.volume_analysis.volume_change_24h:
            if self.volume_analysis.volume_change_24h > 20:
                score += 5  # افزایش حجم
            elif self.volume_analysis.volume_change_24h < -20:
                score -= 5  # کاهش حجم
        
        # بر اساس قدرت روند
        if self.trend_strength > 60:
            score += 15  # روند قوی
        elif self.trend_strength < 20:
            score -= 10  # روند ضعیف
        
        return max(0, min(100, score))  # محدود کردن بین 0 تا 100



# models/notification.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List
from enum import Enum
from datetime import datetime, timedelta
from .base import BaseModel
from .signal import Signal

class NotificationType(Enum):
    """نوع اعلان"""
    SIGNAL = "signal"
    MARKET_UPDATE = "market_update"
    SYSTEM = "system"
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"
    PRICE_ALERT = "price_alert"
    PORTFOLIO_UPDATE = "portfolio_update"

class NotificationPriority(Enum):
    """اولویت اعلان"""
    CRITICAL = 5  # بحرانی
    HIGH = 4      # بالا
    MEDIUM = 3    # متوسط
    LOW = 2       # کم
    INFO = 1      # اطلاعاتی

class NotificationStatus(Enum):
    """وضعیت اعلان"""
    PENDING = "pending"      # در انتظار ارسال
    SENT = "sent"           # ارسال شده
    DELIVERED = "delivered"  # تحویل داده شده
    READ = "read"           # خوانده شده
    FAILED = "failed"       # ناموفق
    EXPIRED = "expired"     # منقضی شده

class DeliveryChannel(Enum):
    """کانال تحویل"""
    TELEGRAM = "telegram"
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"
    WEBHOOK = "webhook"

@dataclass
class NotificationSettings:
    """تنظیمات اعلان"""
    channels: List[DeliveryChannel] = field(default_factory=lambda: [DeliveryChannel.TELEGRAM])
    retry_count: int = 3
    retry_delay: int = 300  # ثانیه
    expires_at: Optional[datetime] = None
    schedule_at: Optional[datetime] = None
    silent: bool = False
    disable_web_page_preview: bool = False

@dataclass
class NotificationMetadata:
    """متادیتای اعلان"""
    source: Optional[str] = None
    category: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    custom_data: Dict[str, Any] = field(default_factory=dict)
    tracking_id: Optional[str] = None

@dataclass
class DeliveryAttempt:
    """تلاش تحویل"""
    channel: DeliveryChannel
    attempted_at: datetime
    status: NotificationStatus
    error_message: Optional[str] = None
    response_data: Optional[Dict[str, Any]] = None

@dataclass
class Notification(BaseModel):
    """مدل پیشرفته اعلان"""
    user_telegram_id: str
    type: NotificationType
    title: str
    message: str
    
    # اختیاری
    signal: Optional[Signal] = None
    priority: NotificationPriority = NotificationPriority.MEDIUM
    status: NotificationStatus = NotificationStatus.PENDING
    settings: NotificationSettings = field(default_factory=NotificationSettings)
    metadata: NotificationMetadata = field(default_factory=NotificationMetadata)
    
    # زمان‌بندی
    scheduled_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    sent_at: Optional[datetime] = None
    delivered_at: Optional[datetime] = None
    read_at: Optional[datetime] = None
    
    # تلاش‌های تحویل
    delivery_attempts: List[DeliveryAttempt] = field(default_factory=list)
    retry_count: int = 0
    max_retries: int = 3
    
    # پیام‌های چندزبانه
    localized_messages: Dict[str, Dict[str, str]] = field(default_factory=dict)
    
    # گروه‌بندی
    group_id: Optional[str] = None
    parent_notification_id: Optional[str] = None
    
    def __post_init__(self):
        """پس از ایجاد شی"""
        if self.expires_at is None and self.priority == NotificationPriority.CRITICAL:
            # اعلانات بحرانی 24 ساعت اعتبار دارند
            self.expires_at = datetime.now() + timedelta(hours=24)
        elif self.expires_at is None:
            # سایر اعلانات 7 روز اعتبار دارند
            self.expires_at = datetime.now() + timedelta(days=7)
    
    @property
    def is_expired(self) -> bool:
        """بررسی انقضاء"""
        return self.expires_at is not None and datetime.now() > self.expires_at
    
    @property
    def is_scheduled(self) -> bool:
        """بررسی زمان‌بندی"""
        return self.scheduled_at is not None and datetime.now() < self.scheduled_at
    
    @property
    def can_retry(self) -> bool:
        """امکان تلاش مجدد"""
        return (self.retry_count < self.max_retries and 
                not self.is_expired and 
                self.status in [NotificationStatus.PENDING, NotificationStatus.FAILED])
    
    @property
    def last_delivery_attempt(self) -> Optional[DeliveryAttempt]:
        """آخرین تلاش تحویل"""
        return self.delivery_attempts[-1] if self.delivery_attempts else None
    
    @property
    def failed_attempts(self) -> List[DeliveryAttempt]:
        """تلاش‌های ناموفق"""
        return [attempt for attempt in self.delivery_attempts 
                if attempt.status == NotificationStatus.FAILED]
    
    @property
    def successful_attempts(self) -> List[DeliveryAttempt]:
        """تلاش‌های موفق"""
        return [attempt for attempt in self.delivery_attempts 
                if attempt.status in [NotificationStatus.SENT, NotificationStatus.DELIVERED]]
    
    def get_localized_message(self, language: str = 'fa') -> Dict[str, str]:
        """دریافت پیام محلی‌سازی شده"""
        if language in self.localized_messages:
            return self.localized_messages[language]
        return {'title': self.title, 'message': self.message}
    
    def add_delivery_attempt(self, channel: DeliveryChannel, status: NotificationStatus,
                            error_message: Optional[str] = None,
                            response_data: Optional[Dict[str, Any]] = None):
        """افزودن تلاش تحویل"""
        attempt = DeliveryAttempt(
            channel=channel,
            attempted_at=datetime.now(),
            status=status,
            error_message=error_message,
            response_data=response_data
        )
        self.delivery_attempts.append(attempt)
        
        if status == NotificationStatus.FAILED:
            self.retry_count += 1
        elif status == NotificationStatus.SENT:
            self.sent_at = datetime.now()
            self.status = NotificationStatus.SENT
        elif status == NotificationStatus.DELIVERED:
            self.delivered_at = datetime.now()
            self.status = NotificationStatus.DELIVERED
    
    def mark_as_read(self):
        """علامت‌گذاری به عنوان خوانده شده"""
        self.read_at = datetime.now()
        self.status = NotificationStatus.READ
    
    def mark_as_expired(self):
        """علامت‌گذاری به عنوان منقضی"""
        self.status = NotificationStatus.EXPIRED
    
    def add_tag(self, tag: str):
        """افزودن برچسب"""
        if tag not in self.metadata.tags:
            self.metadata.tags.append(tag)
    
    def remove_tag(self, tag: str):
        """حذف برچسب"""
        if tag in self.metadata.tags:
            self.metadata.tags.remove(tag)
    
    def has_tag(self, tag: str) -> bool:
        """بررسی وجود برچسب"""
        return tag in self.metadata.tags
    
    def set_custom_data(self, key: str, value: Any):
        """تنظیم داده سفارشی"""
        self.metadata.custom_data[key] = value
    
    def get_custom_data(self, key: str, default: Any = None) -> Any:
        """دریافت داده سفارشی"""
        return self.metadata.custom_data.get(key, default)
    
    def get_priority_text(self) -> str:
        """دریافت متن اولویت"""
        priority_texts = {
            NotificationPriority.CRITICAL: "بحرانی 🔴",
            NotificationPriority.HIGH: "بالا 🟠",
            NotificationPriority.MEDIUM: "متوسط 🟡",
            NotificationPriority.LOW: "کم 🟢",
            NotificationPriority.INFO: "اطلاعاتی 🔵"
        }
        return priority_texts.get(self.priority, "نامشخص")
    
    def get_status_text(self) -> str:
        """دریافت متن وضعیت"""
        status_texts = {
            NotificationStatus.PENDING: "در انتظار",
            NotificationStatus.SENT: "ارسال شده",
            NotificationStatus.DELIVERED: "تحویل داده شده",
            NotificationStatus.READ: "خوانده شده",
            NotificationStatus.FAILED: "ناموفق",
            NotificationStatus.EXPIRED: "منقضی شده"
        }
        return status_texts.get(self.status, "نامشخص")
    
    def format_for_telegram(self, language: str = 'fa') -> str:
        """فرمت برای تلگرام"""
        localized = self.get_localized_message(language)
        priority_emoji = {
            NotificationPriority.CRITICAL: "🚨",
            NotificationPriority.HIGH: "⚠️",
            NotificationPriority.MEDIUM: "ℹ️",
            NotificationPriority.LOW: "💡",
            NotificationPriority.INFO: "📢"
        }.get(self.priority, "📝")
        
        formatted_message = f"{priority_emoji} *{localized['title']}*\n\n"
        formatted_message += f"{localized['message']}\n"
        
        if self.signal:
            formatted_message += f"\n📈 سیگنال: {self.signal.symbol}\n"
            formatted_message += f"📊 نوع: {self.signal.action}\n"
            formatted_message += f"💰 قیمت: {self.signal.entry_price}\n"
        
        if self.metadata.tags:
            formatted_message += f"\n🏷️ برچسب‌ها: {', '.join(self.metadata.tags)}\n"
        
        formatted_message += f"\n⏰ زمان: {self.created_at.strftime('%Y-%m-%d %H:%M')}"
        
        return formatted_message
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Notification':
        """ایجاد از دیکشنری"""
        # تبدیل تاریخ‌ها
        for date_field in ['scheduled_at', 'expires_at', 'sent_at', 'delivered_at', 'read_at']:
            if data.get(date_field):
                data[date_field] = datetime.fromisoformat(data[date_field])
        
        # تبدیل تنظیمات
        if 'settings' in data:
            settings_data = data['settings']
            if 'channels' in settings_data:
                settings_data['channels'] = [DeliveryChannel(ch) for ch in settings_data['channels']]
            data['settings'] = NotificationSettings(**settings_data)
        
        # تبدیل متادیتا
        if 'metadata' in data:
            data['metadata'] = NotificationMetadata(**data['metadata'])
        
        # تبدیل تلاش‌های تحویل
        if 'delivery_attempts' in data:
            attempts = []
            for attempt_data in data['delivery_attempts']:
                attempt_data['channel'] = DeliveryChannel(attempt_data['channel'])
                attempt_data['status'] = NotificationStatus(attempt_data['status'])
                attempt_data['attempted_at'] = datetime.fromisoformat(attempt_data['attempted_at'])
                attempts.append(DeliveryAttempt(**attempt_data))
            data['delivery_attempts'] = attempts
        
        return cls(
            user_telegram_id=data['user_telegram_id'],
            type=NotificationType(data['type']),
            title=data['title'],
            message=data['message'],
            signal=Signal.from_dict(data['signal']) if data.get('signal') else None,
            priority=NotificationPriority(data.get('priority', NotificationPriority.MEDIUM.value)),
            status=NotificationStatus(data.get('status', NotificationStatus.PENDING.value)),
            settings=data.get('settings', NotificationSettings()),
            metadata=data.get('metadata', NotificationMetadata()),
            scheduled_at=data.get('scheduled_at'),
            expires_at=data.get('expires_at'),
            sent_at=data.get('sent_at'),
            delivered_at=data.get('delivered_at'),
            read_at=data.get('read_at'),
            delivery_attempts=data.get('delivery_attempts', []),
            retry_count=data.get('retry_count', 0),
            max_retries=data.get('max_retries', 3),
            localized_messages=data.get('localized_messages', {}),
            group_id=data.get('group_id'),
            parent_notification_id=data.get('parent_notification_id')
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """تبدیل به دیکشنری"""
        result = super().to_dict()
        
        # تبدیل تاریخ‌ها به string
        for date_field in ['scheduled_at', 'expires_at', 'sent_at', 'delivered_at', 'read_at']:
            if getattr(self, date_field):
                result[date_field] = getattr(self, date_field).isoformat()
        
        # تبدیل enum ها
        result['type'] = self.type.value
        result['priority'] = self.priority.value
        result['status'] = self.status.value
        
        # تبدیل تنظیمات
        if self.settings:
            settings_dict = {
                'channels': [ch.value for ch in self.settings.channels],
                'retry_count': self.settings.retry_count,
                'retry_delay': self.settings.retry_delay,
                'silent': self.settings.silent,
                'disable_web_page_preview': self.settings.disable_web_page_preview
            }
            if self.settings.expires_at:
                settings_dict['expires_at'] = self.settings.expires_at.isoformat()
            if self.settings.schedule_at:
                settings_dict['schedule_at'] = self.settings.schedule_at.isoformat()
            result['settings'] = settings_dict
        
        # تبدیل متادیتا
        if self.metadata:
            result['metadata'] = {
                'source': self.metadata.source,
                'category': self.metadata.category,
                'tags': self.metadata.tags,
                'custom_data': self.metadata.custom_data,
                'tracking_id': self.metadata.tracking_id
            }
        
        # تبدیل تلاش‌های تحویل
        if self.delivery_attempts:
            attempts = []
            for attempt in self.delivery_attempts:
                attempt_dict = {
                    'channel': attempt.channel.value,
                    'attempted_at': attempt.attempted_at.isoformat(),
                    'status': attempt.status.value,
                    'error_message': attempt.error_message,
                    'response_data': attempt.response_data
                }
                attempts.append(attempt_dict)
            result['delivery_attempts'] = attempts
        
        return result



# models/signal.py

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union
from decimal import Decimal
from enum import Enum
from datetime import datetime, timedelta
from .base import BaseModel
from .indicators import IndicatorResult

class SignalType(Enum):
    """نوع سیگنال"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"
    SCALP_BUY = "scalp_buy"
    SCALP_SELL = "scalp_sell"
    SWING_BUY = "swing_buy"
    SWING_SELL = "swing_sell"

class SignalStrength(Enum):
    """قدرت سیگنال"""
    VERY_WEAK = "very_weak"
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"
    EXTREMELY_STRONG = "extremely_strong"

class SignalStatus(Enum):
    """وضعیت سیگنال"""
    ACTIVE = "active"
    TRIGGERED = "triggered"
    EXPIRED = "expired"
    CANCELLED = "cancelled"
    COMPLETED = "completed"
    PARTIAL = "partial"

class SignalSource(Enum):
    """منبع سیگنال"""
    TECHNICAL_ANALYSIS = "technical_analysis"
    FUNDAMENTAL_ANALYSIS = "fundamental_analysis"
    SENTIMENT_ANALYSIS = "sentiment_analysis"
    AI_MODEL = "ai_model"
    HYBRID = "hybrid"
    MANUAL = "manual"
    COPY_TRADING = "copy_trading"

class TradingStyle(Enum):
    """سبک معاملاتی"""
    SCALPING = "scalping"
    DAY_TRADING = "day_trading"
    SWING_TRADING = "swing_trading"
    POSITION_TRADING = "position_trading"
    ARBITRAGE = "arbitrage"

class MarketCondition(Enum):
    """وضعیت بازار"""
    TRENDING_UP = "trending_up"
    TRENDING_DOWN = "trending_down"
    SIDEWAYS = "sideways"
    VOLATILE = "volatile"
    LOW_VOLATILITY = "low_volatility"
    BREAKOUT = "breakout"
    REVERSAL = "reversal"

class RiskLevel(Enum):
    """سطح ریسک"""
    VERY_LOW = "very_low"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

@dataclass
class TakeProfitLevel:
    """سطح take profit"""
    level: int
    price: Decimal
    percentage: float
    description: Optional[str] = None

@dataclass
class SignalMetrics:
    """متریک‌های سیگنال"""
    confidence_score: float = 0.0  # 0-100
    risk_reward_ratio: Optional[float] = None
    win_probability: Optional[float] = None
    expected_return: Optional[float] = None
    maximum_loss: Optional[float] = None
    sharpe_ratio: Optional[float] = None
    volatility_score: Optional[float] = None

@dataclass
class SignalValidation:
    """اعتبارسنجی سیگنال"""
    is_validated: bool = False
    validation_score: float = 0.0
    conflicting_signals: int = 0
    supporting_signals: int = 0
    market_structure_aligned: bool = False
    volume_confirmation: bool = False

@dataclass
class SignalExecution:
    """اجرای سیگنال"""
    recommended_position_size: Optional[float] = None
    max_position_size: Optional[float] = None
    entry_method: Optional[str] = None  # market, limit, stop
    partial_entry_levels: List[Decimal] = field(default_factory=list)
    scaling_strategy: Optional[str] = None
    execution_timeframe: Optional[str] = None

@dataclass
class SignalContext:
    """زمینه سیگنال"""
    market_session: Optional[str] = None  # asian, european, american
    news_events: List[str] = field(default_factory=list)
    economic_calendar: List[str] = field(default_factory=list)
    sector_performance: Optional[str] = None
    correlation_assets: List[str] = field(default_factory=list)

@dataclass
class SignalBacktest:
    """بک‌تست سیگنال"""
    historical_accuracy: Optional[float] = None
    average_return: Optional[float] = None
    max_drawdown: Optional[float] = None
    win_rate: Optional[float] = None
    avg_winning_trade: Optional[float] = None
    avg_losing_trade: Optional[float] = None
    total_trades: Optional[int] = None
    profit_factor: Optional[float] = None

@dataclass
class Signal(BaseModel):
    """مدل سیگنال معاملاتی پیشرفته"""
    # اطلاعات اصلی
    id: Optional[str] = None
    symbol: str = ""
    timeframe: str = ""
    type: SignalType = SignalType.HOLD
    strength: SignalStrength = SignalStrength.MODERATE
    status: SignalStatus = SignalStatus.ACTIVE
    source: SignalSource = SignalSource.TECHNICAL_ANALYSIS
    trading_style: TradingStyle = TradingStyle.SWING_TRADING
    
    # قیمت‌ها
    entry_price: Optional[Decimal] = None
    current_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit_levels: List[TakeProfitLevel] = field(default_factory=list)
    
    # متریک‌ها
    metrics: SignalMetrics = field(default_factory=SignalMetrics)
    validation: SignalValidation = field(default_factory=SignalValidation)
    execution: SignalExecution = field(default_factory=SignalExecution)
    context: SignalContext = field(default_factory=SignalContext)
    backtest: SignalBacktest = field(default_factory=SignalBacktest)
    
    # اندیکاتورها و تحلیل
    indicators_used: List[IndicatorResult] = field(default_factory=list)
    technical_patterns: List[str] = field(default_factory=list)
    support_resistance_levels: List[Decimal] = field(default_factory=list)
    
    # شرایط بازار
    market_condition: MarketCondition = MarketCondition.SIDEWAYS
    risk_level: RiskLevel = RiskLevel.MEDIUM
    market_sentiment: Optional[str] = None
    volume_profile: Optional[str] = None
    
    # زمان‌بندی
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: Optional[datetime] = None
    triggered_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    estimated_duration: Optional[timedelta] = None
    
    # اطلاعات اضافی
    notes: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    alerts: List[str] = field(default_factory=list)
    related_signals: List[str] = field(default_factory=list)
    
    # پیگیری عملکرد
    actual_entry_price: Optional[Decimal] = None
    actual_exit_price: Optional[Decimal] = None
    actual_return: Optional[float] = None
    trade_outcome: Optional[str] = None  # win, loss, breakeven
    
    @property
    def is_valid(self) -> bool:
        """آیا سیگنال معتبر است؟"""
        return (
            self.metrics.confidence_score >= 60 and
            self.entry_price and self.entry_price > 0 and
            self.status == SignalStatus.ACTIVE and
            (self.expires_at is None or self.expires_at > datetime.now())
        )
    
    @property
    def is_expired(self) -> bool:
        """آیا سیگنال منقضی شده؟"""
        return self.expires_at is not None and self.expires_at <= datetime.now()
    
    @property
    def risk_percentage(self) -> Optional[float]:
        """درصد ریسک در صورت وجود stop loss"""
        if not self.stop_loss or not self.entry_price or self.entry_price == 0:
            return None
        return float(abs(self.entry_price - self.stop_loss) / self.entry_price * 100)
    
    @property
    def potential_rewards(self) -> List[float]:
        """درصد سودهای بالقوه"""
        if not self.entry_price or self.entry_price == 0:
            return []
        
        rewards = []
        for tp in self.take_profit_levels:
            reward = float(abs(tp.price - self.entry_price) / self.entry_price * 100)
            rewards.append(reward)
        return rewards
    
    @property
    def time_to_expiry(self) -> Optional[timedelta]:
        """زمان باقی‌مانده تا انقضا"""
        if not self.expires_at:
            return None
        return self.expires_at - datetime.now()
    
    @property
    def signal_age(self) -> timedelta:
        """سن سیگنال"""
        return datetime.now() - self.created_at
    
    def calculate_position_size(self, account_balance: Decimal, risk_per_trade: float = 2.0) -> Optional[Decimal]:
        """محاسبه اندازه پوزیشن"""
        if not self.entry_price or not self.stop_loss:
            return None
        
        risk_amount = account_balance * (risk_per_trade / 100)
        price_diff = abs(self.entry_price - self.stop_loss)
        
        if price_diff == 0:
            return None
        
        position_size = risk_amount / price_diff
        return position_size
    
    def get_risk_reward_ratios(self) -> List[float]:
        """محاسبه نسبت ریسک به ریوارد برای هر سطح"""
        if not self.risk_percentage:
            return []
        
        ratios = []
        for reward in self.potential_rewards:
            if self.risk_percentage > 0:
                ratios.append(reward / self.risk_percentage)
        return ratios
    
    def update_status(self, new_status: SignalStatus, notes: Optional[str] = None):
        """بروزرسانی وضعیت سیگنال"""
        self.status = new_status
        self.updated_at = datetime.now()
        
        if new_status == SignalStatus.TRIGGERED:
            self.triggered_at = datetime.now()
        
        if notes:
            if self.notes:
                self.notes += f"\n{datetime.now().strftime('%Y-%m-%d %H:%M')}: {notes}"
            else:
                self.notes = f"{datetime.now().strftime('%Y-%m-%d %H:%M')}: {notes}"
    
    def add_alert(self, alert_message: str):
        """اضافه کردن هشدار"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        self.alerts.append(f"{timestamp}: {alert_message}")
    
    def get_signal_quality_score(self) -> float:
        """محاسبه امتیاز کیفیت سیگنال"""
        score = 0.0
        
        # امتیاز اعتماد (40% وزن)
        score += (self.metrics.confidence_score / 100) * 40
        
        # اعتبارسنجی (20% وزن)
        if self.validation.is_validated:
            score += self.validation.validation_score * 0.2
        
        # نسبت ریسک به ریوارد (20% وزن)
        if self.metrics.risk_reward_ratio and self.metrics.risk_reward_ratio > 1:
            rr_score = min(self.metrics.risk_reward_ratio / 3, 1) * 20
            score += rr_score
        
        # قدرت سیگنال (10% وزن)
        strength_scores = {
            SignalStrength.VERY_WEAK: 0.2,
            SignalStrength.WEAK: 0.4,
            SignalStrength.MODERATE: 0.6,
            SignalStrength.STRONG: 0.8,
            SignalStrength.VERY_STRONG: 1.0,
            SignalStrength.EXTREMELY_STRONG: 1.0
        }
        score += strength_scores.get(self.strength, 0.6) * 10
        
        # بک‌تست (10% وزن)
        if self.backtest.win_rate:
            score += (self.backtest.win_rate / 100) * 10
        
        return min(score, 100)
    
    def is_compatible_with_market(self) -> bool:
        """بررسی سازگاری با شرایط بازار"""
        # بررسی‌های ساده سازگاری
        if self.type in [SignalType.BUY, SignalType.STRONG_BUY] and self.market_condition == MarketCondition.TRENDING_DOWN:
            return False
        
        if self.type in [SignalType.SELL, SignalType.STRONG_SELL] and self.market_condition == MarketCondition.TRENDING_UP:
            return False
        
        return True
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """ایجاد نمونه از دیکشنری"""
        # پردازش take profit levels
        tp_levels = []
        if 'take_profit_levels' in data:
            for tp_data in data['take_profit_levels']:
                tp_levels.append(TakeProfitLevel(
                    level=tp_data['level'],
                    price=Decimal(str(tp_data['price'])),
                    percentage=tp_data['percentage'],
                    description=tp_data.get('description')
                ))
        
        # پردازش indicators
        indicators = []
        if 'indicators_used' in data and data['indicators_used']:
            indicators = [IndicatorResult.from_dict(ind) for ind in data['indicators_used']]
        
        return cls(
            # اطلاعات اصلی
            id=data.get('id'),
            symbol=data.get('symbol', ''),
            timeframe=data.get('timeframe', ''),
            type=SignalType(data.get('type', 'hold')),
            strength=SignalStrength(data.get('strength', 'moderate')),
            status=SignalStatus(data.get('status', 'active')),
            source=SignalSource(data.get('source', 'technical_analysis')),
            trading_style=TradingStyle(data.get('trading_style', 'swing_trading')),
            
            # قیمت‌ها
            entry_price=Decimal(str(data['entry_price'])) if data.get('entry_price') else None,
            current_price=Decimal(str(data['current_price'])) if data.get('current_price') else None,
            stop_loss=Decimal(str(data['stop_loss'])) if data.get('stop_loss') else None,
            take_profit_levels=tp_levels,
            
            # متریک‌ها
            metrics=SignalMetrics(
                confidence_score=data.get('confidence_score', 0.0),
                risk_reward_ratio=data.get('risk_reward_ratio'),
                win_probability=data.get('win_probability'),
                expected_return=data.get('expected_return'),
                maximum_loss=data.get('maximum_loss'),
                sharpe_ratio=data.get('sharpe_ratio'),
                volatility_score=data.get('volatility_score')
            ),
            
            # اعتبارسنجی
            validation=SignalValidation(
                is_validated=data.get('is_validated', False),
                validation_score=data.get('validation_score', 0.0),
                conflicting_signals=data.get('conflicting_signals', 0),
                supporting_signals=data.get('supporting_signals', 0),
                market_structure_aligned=data.get('market_structure_aligned', False),
                volume_confirmation=data.get('volume_confirmation', False)
            ),
            
            # اجرا
            execution=SignalExecution(
                recommended_position_size=data.get('recommended_position_size'),
                max_position_size=data.get('max_position_size'),
                entry_method=data.get('entry_method'),
                partial_entry_levels=[Decimal(str(level)) for level in data.get('partial_entry_levels', [])],
                scaling_strategy=data.get('scaling_strategy'),
                execution_timeframe=data.get('execution_timeframe')
            ),
            
            # زمینه
            context=SignalContext(
                market_session=data.get('market_session'),
                news_events=data.get('news_events', []),
                economic_calendar=data.get('economic_calendar', []),
                sector_performance=data.get('sector_performance'),
                correlation_assets=data.get('correlation_assets', [])
            ),
            
            # بک‌تست
            backtest=SignalBacktest(
                historical_accuracy=data.get('historical_accuracy'),
                average_return=data.get('average_return'),
                max_drawdown=data.get('max_drawdown'),
                win_rate=data.get('win_rate'),
                avg_winning_trade=data.get('avg_winning_trade'),
                avg_losing_trade=data.get('avg_losing_trade'),
                total_trades=data.get('total_trades'),
                profit_factor=data.get('profit_factor')
            ),
            
            # اندیکاتورها
            indicators_used=indicators,
            technical_patterns=data.get('technical_patterns', []),
            support_resistance_levels=[Decimal(str(level)) for level in data.get('support_resistance_levels', [])],
            
            # شرایط بازار
            market_condition=MarketCondition(data.get('market_condition', 'sideways')),
            risk_level=RiskLevel(data.get('risk_level', 'medium')),
            market_sentiment=data.get('market_sentiment'),
            volume_profile=data.get('volume_profile'),
            
            # زمان‌بندی
            created_at=datetime.fromisoformat(data['created_at']) if data.get('created_at') else datetime.now(),
            updated_at=datetime.fromisoformat(data['updated_at']) if data.get('updated_at') else None,
            triggered_at=datetime.fromisoformat(data['triggered_at']) if data.get('triggered_at') else None,
            expires_at=datetime.fromisoformat(data['expires_at']) if data.get('expires_at') else None,
            estimated_duration=timedelta(seconds=data['estimated_duration']) if data.get('estimated_duration') else None,
            
            # اطلاعات اضافی
            notes=data.get('notes'),
            tags=data.get('tags', []),
            alerts=data.get('alerts', []),
            related_signals=data.get('related_signals', []),
            
            # پیگیری عملکرد
            actual_entry_price=Decimal(str(data['actual_entry_price'])) if data.get('actual_entry_price') else None,
            actual_exit_price=Decimal(str(data['actual_exit_price'])) if data.get('actual_exit_price') else None,
            actual_return=data.get('actual_return'),
            trade_outcome=data.get('trade_outcome')
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """تبدیل به دیکشنری"""
        return {
            # اطلاعات اصلی
            'id': self.id,
            'symbol': self.symbol,
            'timeframe': self.timeframe,
            'type': self.type.value,
            'strength': self.strength.value,
            'status': self.status.value,
            'source': self.source.value,
            'trading_style': self.trading_style.value,
            
            # قیمت‌ها
            'entry_price': str(self.entry_price) if self.entry_price else None,
            'current_price': str(self.current_price) if self.current_price else None,
            'stop_loss': str(self.stop_loss) if self.stop_loss else None,
            'take_profit_levels': [
                {
                    'level': tp.level,
                    'price': str(tp.price),
                    'percentage': tp.percentage,
                    'description': tp.description
                } for tp in self.take_profit_levels
            ],
            
            # متریک‌ها
            'confidence_score': self.metrics.confidence_score,
            'risk_reward_ratio': self.metrics.risk_reward_ratio,
            'win_probability': self.metrics.win_probability,
            'expected_return': self.metrics.expected_return,
            'maximum_loss': self.metrics.maximum_loss,
            'sharpe_ratio': self.metrics.sharpe_ratio,
            'volatility_score': self.metrics.volatility_score,
            
            # اعتبارسنجی
            'is_validated': self.validation.is_validated,
            'validation_score': self.validation.validation_score,
            'conflicting_signals': self.validation.conflicting_signals,
            'supporting_signals': self.validation.supporting_signals,
            'market_structure_aligned': self.validation.market_structure_aligned,
            'volume_confirmation': self.validation.volume_confirmation,
            
            # اجرا
            'recommended_position_size': self.execution.recommended_position_size,
            'max_position_size': self.execution.max_position_size,
            'entry_method': self.execution.entry_method,
            'partial_entry_levels': [str(level) for level in self.execution.partial_entry_levels],
            'scaling_strategy': self.execution.scaling_strategy,
            'execution_timeframe': self.execution.execution_timeframe,
            
            # زمینه
            'market_session': self.context.market_session,
            'news_events': self.context.news_events,
            'economic_calendar': self.context.economic_calendar,
            'sector_performance': self.context.sector_performance,
            'correlation_assets': self.context.correlation_assets,
            
            # بک‌تست
            'historical_accuracy': self.backtest.historical_accuracy,
            'average_return': self.backtest.average_return,
            'max_drawdown': self.backtest.max_drawdown,
            'win_rate': self.backtest.win_rate,
            'avg_winning_trade': self.backtest.avg_winning_trade,
            'avg_losing_trade': self.backtest.avg_losing_trade,
            'total_trades': self.backtest.total_trades,
            'profit_factor': self.backtest.profit_factor,
            
            # اندیکاتورها
            'indicators_used': [ind.to_dict() for ind in self.indicators_used],
            'technical_patterns': self.technical_patterns,
            'support_resistance_levels': [str(level) for level in self.support_resistance_levels],
            
            # شرایط بازار
            'market_condition': self.market_condition.value,
            'risk_level': self.risk_level.value,
            'market_sentiment': self.market_sentiment,
            'volume_profile': self.volume_profile,
            
            # زمان‌بندی
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'triggered_at': self.triggered_at.isoformat() if self.triggered_at else None,
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'estimated_duration': self.estimated_duration.total_seconds() if self.estimated_duration else None,
            
            # اطلاعات اضافی
            'notes': self.notes,
            'tags': self.tags,
            'alerts': self.alerts,
            'related_signals': self.related_signals,
            
            # پیگیری عملکرد
            'actual_entry_price': str(self.actual_entry_price) if self.actual_entry_price else None,
            'actual_exit_price': str(self.actual_exit_price) if self.actual_exit_price else None,
            'actual_return': self.actual_return,
            'trade_outcome': self.trade_outcome
        }
    
    def get_summary(self) -> str:
        """خلاصه سیگنال"""
        summary = f"{self.type.value.upper()} {self.symbol} ({self.timeframe})\n"
        summary += f"Strength: {self.strength.value.title()}\n"
        summary += f"Confidence: {self.metrics.confidence_score:.1f}%\n"
        
        if self.entry_price:
            summary += f"Entry: ${self.entry_price}\n"
        
        if self.stop_loss:
            summary += f"Stop Loss: ${self.stop_loss}\n"
        
        if self.take_profit_levels:
            summary += f"Take Profits: {len(self.take_profit_levels)} levels\n"
        
        if self.metrics.risk_reward_ratio:
            summary += f"R:R Ratio: 1:{self.metrics.risk_reward_ratio:.2f}\n"
        
        return summary



# models/strategy.py
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Union
from enum import Enum
from datetime import datetime, timedelta
from decimal import Decimal
from .base import BaseModel
from .signal import Signal

class StrategyType(Enum):
    """نوع استراتژی"""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    SCALPING = "scalping"
    SWING = "swing"
    ARBITRAGE = "arbitrage"
    MOMENTUM = "momentum"
    CONTRARIAN = "contrarian"
    GRID = "grid"
    MARTINGALE = "martingale"

class MarketCondition(Enum):
    """شرایط بازار"""
    TRENDING = "trending"
    RANGING = "ranging"
    VOLATILE = "volatile"
    LOW_VOLATILITY = "low_volatility"
    BULLISH = "bullish"
    BEARISH = "bearish"
    SIDEWAYS = "sideways"

class RiskLevel(Enum):
    """سطح ریسک"""
    VERY_LOW = "very_low"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

@dataclass
class TradingHours:
    """ساعات معاملاتی"""
    start_time: str  # Format: "HH:MM"
    end_time: str   # Format: "HH:MM"
    timezone: str = "UTC"
    days_of_week: List[int] = field(default_factory=lambda: [0, 1, 2, 3, 4])  # Monday-Friday
    
    def is_active_now(self) -> bool:
        """آیا در حال حاضر در ساعات معاملاتی هستیم؟"""
        now = datetime.now()
        return (
            now.weekday() in self.days_of_week and
            self.start_time <= now.strftime("%H:%M") <= self.end_time
        )

@dataclass
class StrategyParameters:
    """پارامترهای استراتژی"""
    entry_conditions: Dict[str, Any] = field(default_factory=dict)
    exit_conditions: Dict[str, Any] = field(default_factory=dict)
    stop_loss_pips: Optional[float] = None
    take_profit_pips: Optional[float] = None
    trailing_stop: bool = False
    trailing_stop_distance: Optional[float] = None
    max_spread: Optional[float] = None
    min_volume: Optional[int] = None
    
    def validate(self) -> List[str]:
        """اعتبارسنجی پارامترها"""
        errors = []
        if self.stop_loss_pips and self.stop_loss_pips <= 0:
            errors.append("Stop loss must be positive")
        if self.take_profit_pips and self.take_profit_pips <= 0:
            errors.append("Take profit must be positive")
        if self.trailing_stop and not self.trailing_stop_distance:
            errors.append("Trailing stop distance required when trailing stop is enabled")
        return errors

@dataclass
class BacktestMetrics:
    """معیارهای بک‌تست"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_profit: Decimal = Decimal('0')
    total_loss: Decimal = Decimal('0')
    max_drawdown: Decimal = Decimal('0')
    sharpe_ratio: Optional[float] = None
    profit_factor: Optional[float] = None
    win_rate: float = 0.0
    average_win: Decimal = Decimal('0')
    average_loss: Decimal = Decimal('0')
    largest_win: Decimal = Decimal('0')
    largest_loss: Decimal = Decimal('0')
    consecutive_wins: int = 0
    consecutive_losses: int = 0
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    
    @property
    def net_profit(self) -> Decimal:
        """سود خالص"""
        return self.total_profit - abs(self.total_loss)
    
    @property
    def expectancy(self) -> Decimal:
        """انتظار ریاضی"""
        if self.total_trades == 0:
            return Decimal('0')
        return (self.win_rate * self.average_win) - ((1 - self.win_rate) * abs(self.average_loss))

@dataclass
class MarketFilter:
    """فیلتر شرایط بازار"""
    required_conditions: List[MarketCondition] = field(default_factory=list)
    forbidden_conditions: List[MarketCondition] = field(default_factory=list)
    min_volatility: Optional[float] = None
    max_volatility: Optional[float] = None
    min_volume: Optional[int] = None
    news_filter: bool = False
    economic_calendar_filter: bool = False
    
    def check_conditions(self, current_condition: MarketCondition, 
                        volatility: float, volume: int) -> bool:
        """بررسی شرایط فیلتر"""
        if current_condition in self.forbidden_conditions:
            return False
        if self.required_conditions and current_condition not in self.required_conditions:
            return False
        if self.min_volatility and volatility < self.min_volatility:
            return False
        if self.max_volatility and volatility > self.max_volatility:
            return False
        if self.min_volume and volume < self.min_volume:
            return False
        return True

@dataclass
class Strategy(BaseModel):
    """مدل استراتژی معاملاتی پیشرفته"""
    name: str
    type: StrategyType
    description: str
    version: str = "1.0.0"
    author: str = ""
    
    # تنظیمات اصلی
    timeframes: List[str] = field(default_factory=list)
    symbols: List[str] = field(default_factory=list)  # نمادهای قابل معامله
    indicators_required: List[str] = field(default_factory=list)
    
    # تنظیمات ریسک
    risk_level: RiskLevel = RiskLevel.MEDIUM
    min_confidence: float = 70.0
    risk_reward_min: float = 2.0
    max_risk_per_trade: float = 2.0  # درصد سرمایه
    max_daily_loss: float = 5.0      # درصد سرمایه
    max_open_positions: int = 3
    
    # پارامترهای استراتژی
    parameters: StrategyParameters = field(default_factory=StrategyParameters)
    
    # فیلترها
    market_filter: MarketFilter = field(default_factory=MarketFilter)
    trading_hours: Optional[TradingHours] = None
    
    # تنظیمات فعالیت
    is_active: bool = True
    is_backtesting: bool = False
    is_paper_trading: bool = False
    is_live_trading: bool = False
    
    # آمار عملکرد
    backtest_metrics: Optional[BacktestMetrics] = None
    last_updated: datetime = field(default_factory=datetime.now)
    created_at: datetime = field(default_factory=datetime.now)
    
    # تنظیمات اضافی
    config: Dict[str, Any] = field(default_factory=dict)
    tags: List[str] = field(default_factory=list)
    category: str = ""
    
    def __post_init__(self):
        """اعمال تنظیمات پس از ایجاد"""
        if not self.parameters:
            self.parameters = StrategyParameters()
        if not self.market_filter:
            self.market_filter = MarketFilter()
    
    def validate(self) -> List[str]:
        """اعتبارسنجی استراتژی"""
        errors = []
        
        if not self.name:
            errors.append("Strategy name is required")
        if not self.timeframes:
            errors.append("At least one timeframe is required")
        if self.min_confidence < 0 or self.min_confidence > 100:
            errors.append("Confidence must be between 0 and 100")
        if self.risk_reward_min <= 0:
            errors.append("Risk/reward ratio must be positive")
        if self.max_risk_per_trade <= 0 or self.max_risk_per_trade > 100:
            errors.append("Risk per trade must be between 0 and 100")
        
        # اعتبارسنجی پارامترها
        errors.extend(self.parameters.validate())
        
        return errors
    
    def is_valid_for_symbol(self, symbol: str) -> bool:
        """آیا استراتژی برای این نماد قابل اجرا است؟"""
        if not self.symbols:
            return True  # اگر محدودیتی نباشد، همه نمادها مجاز هستند
        return symbol in self.symbols
    
    def is_valid_for_timeframe(self, timeframe: str) -> bool:
        """آیا استراتژی برای این تایم‌فریم قابل اجرا است؟"""
        return timeframe in self.timeframes
    
    def can_trade_now(self) -> bool:
        """آیا در حال حاضر می‌توان معامله کرد؟"""
        if not self.is_active:
            return False
        if self.trading_hours and not self.trading_hours.is_active_now():
            return False
        return True
    
    def update_performance(self, metrics: BacktestMetrics):
        """به‌روزرسانی معیارهای عملکرد"""
        self.backtest_metrics = metrics
        self.last_updated = datetime.now()
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Strategy':
        """ایجاد از دیکشنری"""
        # پردازش تاریخ‌ها
        if 'created_at' in data and isinstance(data['created_at'], str):
            data['created_at'] = datetime.fromisoformat(data['created_at'])
        if 'last_updated' in data and isinstance(data['last_updated'], str):
            data['last_updated'] = datetime.fromisoformat(data['last_updated'])
        
        # پردازش پارامترها
        if 'parameters' in data:
            data['parameters'] = StrategyParameters(**data['parameters'])
        
        # پردازش فیلتر بازار
        if 'market_filter' in data:
            filter_data = data['market_filter']
            if 'required_conditions' in filter_data:
                filter_data['required_conditions'] = [
                    MarketCondition(c) for c in filter_data['required_conditions']
                ]
            if 'forbidden_conditions' in filter_data:
                filter_data['forbidden_conditions'] = [
                    MarketCondition(c) for c in filter_data['forbidden_conditions']
                ]
            data['market_filter'] = MarketFilter(**filter_data)
        
        # پردازش ساعات معاملاتی
        if 'trading_hours' in data and data['trading_hours']:
            data['trading_hours'] = TradingHours(**data['trading_hours'])
        
        # پردازش معیارهای بک‌تست
        if 'backtest_metrics' in data and data['backtest_metrics']:
            metrics_data = data['backtest_metrics']
            # تبدیل Decimal
            for key in ['total_profit', 'total_loss', 'max_drawdown', 'average_win', 
                       'average_loss', 'largest_win', 'largest_loss']:
                if key in metrics_data and metrics_data[key] is not None:
                    metrics_data[key] = Decimal(str(metrics_data[key]))
            # تبدیل تاریخ‌ها
            for key in ['start_date', 'end_date']:
                if key in metrics_data and isinstance(metrics_data[key], str):
                    metrics_data[key] = datetime.fromisoformat(metrics_data[key])
            data['backtest_metrics'] = BacktestMetrics(**metrics_data)
        
        return cls(
            name=data['name'],
            type=StrategyType(data['type']),
            description=data['description'],
            version=data.get('version', '1.0.0'),
            author=data.get('author', ''),
            timeframes=data.get('timeframes', []),
            symbols=data.get('symbols', []),
            indicators_required=data.get('indicators_required', []),
            risk_level=RiskLevel(data.get('risk_level', 'medium')),
            min_confidence=data.get('min_confidence', 70.0),
            risk_reward_min=data.get('risk_reward_min', 2.0),
            max_risk_per_trade=data.get('max_risk_per_trade', 2.0),
            max_daily_loss=data.get('max_daily_loss', 5.0),
            max_open_positions=data.get('max_open_positions', 3),
            parameters=data.get('parameters', StrategyParameters()),
            market_filter=data.get('market_filter', MarketFilter()),
            trading_hours=data.get('trading_hours'),
            is_active=data.get('is_active', True),
            is_backtesting=data.get('is_backtesting', False),
            is_paper_trading=data.get('is_paper_trading', False),
            is_live_trading=data.get('is_live_trading', False),
            backtest_metrics=data.get('backtest_metrics'),
            last_updated=data.get('last_updated', datetime.now()),
            created_at=data.get('created_at', datetime.now()),
            config=data.get('config', {}),
            tags=data.get('tags', []),
            category=data.get('category', '')
        )

@dataclass
class StrategyResult(BaseModel):
    """نتیجه اجرای استراتژی پیشرفته"""
    strategy: Strategy
    symbol: str
    timeframe: str
    timestamp: datetime = field(default_factory=datetime.now)
    
    # نتیجه سیگنال
    signal: Optional[Signal] = None
    confidence: float = 0.0
    score: float = 0.0
    
    # جزئیات فیلترها
    passed_filters: List[str] = field(default_factory=list)
    failed_filters: List[str] = field(default_factory=list)
    filter_scores: Dict[str, float] = field(default_factory=dict)
    
    # شرایط بازار
    market_condition: Optional[MarketCondition] = None
    volatility: Optional[float] = None
    volume: Optional[int] = None
    spread: Optional[float] = None
    
    # معیارهای ریسک
    risk_assessment: Dict[str, Any] = field(default_factory=dict)
    expected_risk_reward: Optional[float] = None
    position_size_suggested: Optional[float] = None
    
    # اطلاعات اضافی
    indicators_values: Dict[str, Any] = field(default_factory=dict)
    execution_time_ms: Optional[float] = None
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    
    @property
    def is_successful(self) -> bool:
        """آیا استراتژی موفق بوده؟"""
        return (
            self.signal is not None and 
            self.signal.is_valid and 
            len(self.failed_filters) == 0 and
            self.confidence >= self.strategy.min_confidence
        )
    
    @property
    def filter_pass_rate(self) -> float:
        """درصد موفقیت فیلترها"""
        total_filters = len(self.passed_filters) + len(self.failed_filters)
        if total_filters == 0:
            return 100.0
        return (len(self.passed_filters) / total_filters) * 100
    
    @property
    def quality_score(self) -> float:
        """امتیاز کیفیت کلی"""
        base_score = self.score
        confidence_bonus = (self.confidence - self.strategy.min_confidence) / 100
        filter_bonus = self.filter_pass_rate / 100
        
        return min(100.0, base_score + (confidence_bonus * 20) + (filter_bonus * 10))
    
    def add_error(self, error: str):
        """افزودن خطا"""
        if error not in self.errors:
            self.errors.append(error)
    
    def add_warning(self, warning: str):
        """افزودن هشدار"""
        if warning not in self.warnings:
            self.warnings.append(warning)
    
    def has_errors(self) -> bool:
        """آیا خطایی وجود دارد؟"""
        return len(self.errors) > 0
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'StrategyResult':
        """ایجاد از دیکشنری"""
        if 'timestamp' in data and isinstance(data['timestamp'], str):
            data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        
        if 'market_condition' in data and data['market_condition']:
            data['market_condition'] = MarketCondition(data['market_condition'])
        
        return cls(
            strategy=Strategy.from_dict(data['strategy']),
            symbol=data['symbol'],
            timeframe=data['timeframe'],
            timestamp=data.get('timestamp', datetime.now()),
            signal=Signal.from_dict(data['signal']) if data.get('signal') else None,
            confidence=data.get('confidence', 0.0),
            score=data.get('score', 0.0),
            passed_filters=data.get('passed_filters', []),
            failed_filters=data.get('failed_filters', []),
            filter_scores=data.get('filter_scores', {}),
            market_condition=data.get('market_condition'),
            volatility=data.get('volatility'),
            volume=data.get('volume'),
            spread=data.get('spread'),
            risk_assessment=data.get('risk_assessment', {}),
            expected_risk_reward=data.get('expected_risk_reward'),
            position_size_suggested=data.get('position_size_suggested'),
            indicators_values=data.get('indicators_values', {}),
            execution_time_ms=data.get('execution_time_ms'),
            errors=data.get('errors', []),
            warnings=data.get('warnings', [])
        )

@dataclass
class StrategyCollection:
    """مجموعه‌ای از استراتژی‌ها"""
    name: str
    strategies: List[Strategy] = field(default_factory=list)
    description: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    
    def add_strategy(self, strategy: Strategy):
        """افزودن استراتژی"""
        if strategy not in self.strategies:
            self.strategies.append(strategy)
    
    def remove_strategy(self, strategy_name: str):
        """حذف استراتژی"""
        self.strategies = [s for s in self.strategies if s.name != strategy_name]
    
    def get_active_strategies(self) -> List[Strategy]:
        """دریافت استراتژی‌های فعال"""
        return [s for s in self.strategies if s.is_active]
    
    def get_strategies_by_type(self, strategy_type: StrategyType) -> List[Strategy]:
        """دریافت استراتژی‌ها بر اساس نوع"""
        return [s for s in self.strategies if s.type == strategy_type]
    
    def get_strategies_for_symbol(self, symbol: str) -> List[Strategy]:
        """دریافت استراتژی‌های قابل اجرا برای نماد"""
        return [s for s in self.strategies if s.is_valid_for_symbol(symbol)]



# models/timeframe.py

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
from .base import BaseModel

class TimeFrameType(Enum):
    """انواع تایم فریم"""
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    M30 = "30m"
    H1 = "1h"
    H2 = "2h"
    H4 = "4h"
    H6 = "6h"
    H8 = "8h"
    H12 = "12h"
    D1 = "1d"
    D2 = "2d"
    D3 = "3d"
    D5 = "5d"
    W1 = "1w"
    W2 = "2w"
    MN1 = "1M"
    MN3 = "3M"

class TimeFrameCategory(Enum):
    """دسته‌بندی تایم فریم‌ها"""
    SCALPING = "scalping"          # M1, M5
    INTRADAY = "intraday"          # M15, M30, H1, H2
    SHORT_TERM = "short_term"      # H4, H6, H8, H12
    SWING = "swing"                # D1, D2, D3
    POSITION = "position"          # W1, W2, MN1, MN3

class TimeFrameGroup(Enum):
    """گروه‌بندی تایم فریم‌ها بر اساس استفاده"""
    MINUTE = "minute"
    HOURLY = "hourly"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"

@dataclass
class TimeFrameConfig:
    """تنظیمات اضافی برای هر تایم فریم"""
    max_candles: int = 1000        # حداکثر تعداد کندل قابل دریافت
    min_candles: int = 50          # حداقل تعداد کندل مورد نیاز
    chart_color: str = "#1f77b4"  # رنگ پیش‌فرض در چارت
    is_recommended: bool = False   # آیا این تایم فریم توصیه شده است
    risk_level: str = "medium"     # سطح ریسک: low, medium, high
    volatility_factor: float = 1.0 # ضریب نوسان
    analysis_weight: float = 1.0   # وزن در تحلیل چندتایم فریمه

@dataclass
class TimeFrame(BaseModel):
    """مدل تایم فریم با جزئیات کامل"""
    type: TimeFrameType
    interval_minutes: int
    display_name: str
    display_name_en: str = ""
    priority: int = 0
    is_active: bool = True
    category: TimeFrameCategory = TimeFrameCategory.INTRADAY
    group: TimeFrameGroup = TimeFrameGroup.HOURLY
    config: TimeFrameConfig = field(default_factory=TimeFrameConfig)
    description: str = ""
    typical_holding_period: str = ""  # مدت زمان معمول نگهداری پوزیشن
    suitable_for: List[str] = field(default_factory=list)  # مناسب برای چه نوع معامله‌گری
    related_timeframes: List[str] = field(default_factory=list)  # تایم فریم‌های مرتبط
    technical_indicators: List[str] = field(default_factory=list)  # اندیکاتورهای مناسب
    
    def __post_init__(self):
        """تنظیمات اولیه پس از ایجاد آبجکت"""
        if not self.display_name_en:
            self.display_name_en = self.type.value
        
        # تنظیم خودکار دسته‌بندی بر اساس interval_minutes
        self._auto_set_category()
        self._auto_set_group()
        self._set_default_config()
    
    def _auto_set_category(self):
        """تنظیم خودکار دسته‌بندی"""
        if self.interval_minutes <= 5:
            self.category = TimeFrameCategory.SCALPING
        elif self.interval_minutes <= 120:
            self.category = TimeFrameCategory.INTRADAY
        elif self.interval_minutes <= 720:
            self.category = TimeFrameCategory.SHORT_TERM
        elif self.interval_minutes <= 4320:  # 3 روز
            self.category = TimeFrameCategory.SWING
        else:
            self.category = TimeFrameCategory.POSITION
    
    def _auto_set_group(self):
        """تنظیم خودکار گروه"""
        if self.interval_minutes < 60:
            self.group = TimeFrameGroup.MINUTE
        elif self.interval_minutes < 1440:
            self.group = TimeFrameGroup.HOURLY
        elif self.interval_minutes < 10080:  # یک هفته
            self.group = TimeFrameGroup.DAILY
        elif self.interval_minutes < 43200:  # یک ماه
            self.group = TimeFrameGroup.WEEKLY
        else:
            self.group = TimeFrameGroup.MONTHLY
    
    def _set_default_config(self):
        """تنظیم پیکربندی پیش‌فرض بر اساس نوع تایم فریم"""
        category_configs = {
            TimeFrameCategory.SCALPING: TimeFrameConfig(
                max_candles=2000,
                min_candles=100,
                chart_color="#ff6b6b",
                risk_level="high",
                volatility_factor=2.0,
                analysis_weight=0.5
            ),
            TimeFrameCategory.INTRADAY: TimeFrameConfig(
                max_candles=1500,
                min_candles=75,
                chart_color="#4ecdc4",
                risk_level="medium",
                volatility_factor=1.5,
                analysis_weight=1.0
            ),
            TimeFrameCategory.SHORT_TERM: TimeFrameConfig(
                max_candles=1000,
                min_candles=50,
                chart_color="#45b7d1",
                is_recommended=True,
                risk_level="medium",
                volatility_factor=1.0,
                analysis_weight=1.5
            ),
            TimeFrameCategory.SWING: TimeFrameConfig(
                max_candles=800,
                min_candles=30,
                chart_color="#96ceb4",
                is_recommended=True,
                risk_level="low",
                volatility_factor=0.8,
                analysis_weight=2.0
            ),
            TimeFrameCategory.POSITION: TimeFrameConfig(
                max_candles=500,
                min_candles=20,
                chart_color="#feca57",
                risk_level="low",
                volatility_factor=0.5,
                analysis_weight=2.5
            )
        }
        
        if hasattr(self, 'config') and self.config and any(vars(self.config).values()):
            # اگر config از قبل تنظیم شده، آن را نگه می‌داریم
            pass
        else:
            self.config = category_configs.get(self.category, TimeFrameConfig())
    
    @property
    def value(self) -> str:
        """مقدار رشته‌ای تایم فریم"""
        return self.type.value
    
    @property
    def interval_seconds(self) -> int:
        """بازه زمانی به ثانیه"""
        return self.interval_minutes * 60
    
    @property
    def interval_hours(self) -> float:
        """بازه زمانی به ساعت"""
        return self.interval_minutes / 60
    
    @property
    def interval_days(self) -> float:
        """بازه زمانی به روز"""
        return self.interval_minutes / 1440
    
    @property
    def is_intraday(self) -> bool:
        """آیا تایم فریم روزانه است"""
        return self.interval_minutes < 1440
    
    @property
    def is_short_term(self) -> bool:
        """آیا تایم فریم کوتاه مدت است"""
        return self.category in [TimeFrameCategory.SCALPING, TimeFrameCategory.INTRADAY]
    
    @property
    def is_long_term(self) -> bool:
        """آیا تایم فریم بلند مدت است"""
        return self.category in [TimeFrameCategory.SWING, TimeFrameCategory.POSITION]
    
    def get_candles_for_period(self, days: int) -> int:
        """محاسبه تعداد کندل‌های مورد نیاز برای یک دوره زمانی"""
        total_minutes = days * 24 * 60
        return int(total_minutes / self.interval_minutes)
    
    def get_period_for_candles(self, candles: int) -> float:
        """محاسبه دوره زمانی بر اساس تعداد کندل (به روز)"""
        total_minutes = candles * self.interval_minutes
        return total_minutes / (24 * 60)
    
    def calculate_next_candle_time(self, current_time: datetime) -> datetime:
        """محاسبه زمان کندل بعدی"""
        interval_td = timedelta(minutes=self.interval_minutes)
        
        # گرد کردن زمان به نزدیک‌ترین بازه
        if self.interval_minutes < 60:
            # برای تایم فریم‌های دقیقه‌ای
            minutes = (current_time.minute // self.interval_minutes + 1) * self.interval_minutes
            next_time = current_time.replace(minute=0, second=0, microsecond=0)
            next_time += timedelta(minutes=minutes)
        else:
            # برای تایم فریم‌های ساعتی و بالاتر
            next_time = current_time + interval_td
        
        return next_time
    
    def is_compatible_with(self, other: 'TimeFrame') -> bool:
        """بررسی سازگاری با تایم فریم دیگر برای تحلیل چندتایم فریمه"""
        # تایم فریم‌های سازگار باید نسبت صحیحی داشته باشند
        ratio1 = other.interval_minutes / self.interval_minutes
        ratio2 = self.interval_minutes / other.interval_minutes
        
        # یکی از نسبت‌ها باید عدد صحیح باشد
        return ratio1.is_integer() or ratio2.is_integer()
    
    def get_higher_timeframes(self) -> List['TimeFrame']:
        """دریافت تایم فریم‌های بالاتر سازگار"""
        all_timeframes = self.get_all_active()
        higher_timeframes = []
        
        for tf in all_timeframes:
            if (tf.interval_minutes > self.interval_minutes and 
                self.is_compatible_with(tf)):
                higher_timeframes.append(tf)
        
        return sorted(higher_timeframes, key=lambda x: x.interval_minutes)
    
    def get_lower_timeframes(self) -> List['TimeFrame']:
        """دریافت تایم فریم‌های پایین‌تر سازگار"""
        all_timeframes = self.get_all_active()
        lower_timeframes = []
        
        for tf in all_timeframes:
            if (tf.interval_minutes < self.interval_minutes and 
                self.is_compatible_with(tf)):
                lower_timeframes.append(tf)
        
        return sorted(lower_timeframes, key=lambda x: x.interval_minutes, reverse=True)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TimeFrame':
        """ایجاد از دیکشنری"""
        config_data = data.get('config', {})
        config = TimeFrameConfig(**config_data) if config_data else TimeFrameConfig()
        
        return cls(
            type=TimeFrameType(data['type']),
            interval_minutes=data['interval_minutes'],
            display_name=data['display_name'],
            display_name_en=data.get('display_name_en', ''),
            priority=data.get('priority', 0),
            is_active=data.get('is_active', True),
            category=TimeFrameCategory(data.get('category', 'intraday')),
            group=TimeFrameGroup(data.get('group', 'hourly')),
            config=config,
            description=data.get('description', ''),
            typical_holding_period=data.get('typical_holding_period', ''),
            suitable_for=data.get('suitable_for', []),
            related_timeframes=data.get('related_timeframes', []),
            technical_indicators=data.get('technical_indicators', [])
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """تبدیل به دیکشنری"""
        return {
            'type': self.type.value,
            'interval_minutes': self.interval_minutes,
            'display_name': self.display_name,
            'display_name_en': self.display_name_en,
            'priority': self.priority,
            'is_active': self.is_active,
            'category': self.category.value,
            'group': self.group.value,
            'config': vars(self.config),
            'description': self.description,
            'typical_holding_period': self.typical_holding_period,
            'suitable_for': self.suitable_for,
            'related_timeframes': self.related_timeframes,
            'technical_indicators': self.technical_indicators
        }
    
    @classmethod
    def get_all_active(cls) -> List['TimeFrame']:
        """دریافت همه تایم فریم‌های فعال با جزئیات کامل"""
        timeframes = [
            cls(
                type=TimeFrameType.M1,
                interval_minutes=1,
                display_name="1 دقیقه",
                display_name_en="1 Minute",
                priority=1,
                description="مناسب برای اسکالپینگ و معاملات فوری",
                typical_holding_period="1-5 دقیقه",
                suitable_for=["اسکالپینگ", "معاملات فوری", "ورود دقیق"],
                related_timeframes=["5m", "15m"],
                technical_indicators=["RSI", "Stochastic", "MACD", "Bollinger Bands"]
            ),
            cls(
                type=TimeFrameType.M5,
                interval_minutes=5,
                display_name="5 دقیقه",
                display_name_en="5 Minutes",
                priority=2,
                description="مناسب برای اسکالپینگ و معاملات کوتاه مدت",
                typical_holding_period="5-30 دقیقه",
                suitable_for=["اسکالپینگ", "تأیید سیگنال", "معاملات سریع"],
                related_timeframes=["1m", "15m", "30m"],
                technical_indicators=["EMA", "RSI", "MACD", "Support/Resistance"]
            ),
            cls(
                type=TimeFrameType.M15,
                interval_minutes=15,
                display_name="15 دقیقه",
                display_name_en="15 Minutes",
                priority=3,
                description="مناسب برای معاملات روزانه و تحلیل کوتاه مدت",
                typical_holding_period="30 دقیقه - 2 ساعت",
                suitable_for=["معاملات روزانه", "تحلیل تکنیکال", "تأیید ترند"],
                related_timeframes=["5m", "30m", "1h"],
                technical_indicators=["Moving Averages", "RSI", "MACD", "Fibonacci"]
            ),
            cls(
                type=TimeFrameType.M30,
                interval_minutes=30,
                display_name="30 دقیقه",
                display_name_en="30 Minutes",
                priority=4,
                description="ترکیب خوب از سرعت و دقت برای معاملات روزانه",
                typical_holding_period="1-4 ساعت",
                suitable_for=["معاملات روزانه", "تحلیل متوسط مدت", "ترند فالوئینگ"],
                related_timeframes=["15m", "1h", "2h"],
                technical_indicators=["Trend Lines", "Moving Averages", "RSI", "Volume"]
            ),
            cls(
                type=TimeFrameType.H1,
                interval_minutes=60,
                display_name="1 ساعت",
                display_name_en="1 Hour",
                priority=5,
                description="استاندارد طلایی برای اکثر معامله‌گران",
                typical_holding_period="2-8 ساعت",
                suitable_for=["معاملات روزانه", "تحلیل جامع", "ترند شناسی"],
                related_timeframes=["30m", "2h", "4h"],
                technical_indicators=["All Major Indicators", "Chart Patterns", "Support/Resistance"]
            ),
            cls(
                type=TimeFrameType.H2,
                interval_minutes=120,
                display_name="2 ساعت",
                display_name_en="2 Hours",
                priority=6,
                description="مناسب برای معاملات متوسط مدت",
                typical_holding_period="4-12 ساعت",
                suitable_for=["معاملات متوسط", "تحلیل ترند", "کاهش نویز"],
                related_timeframes=["1h", "4h", "6h"],
                technical_indicators=["Trend Analysis", "Moving Averages", "Momentum Indicators"]
            ),
            cls(
                type=TimeFrameType.H4,
                interval_minutes=240,
                display_name="4 ساعت",
                display_name_en="4 Hours",
                priority=7,
                description="بهترین تایم فریم برای تحلیل ترند و سوئینگ",
                typical_holding_period="8 ساعت - 2 روز",
                suitable_for=["سوئینگ ترید", "تحلیل ترند", "نقاط ورود استراتژیک"],
                related_timeframes=["2h", "6h", "1d"],
                technical_indicators=["Trend Analysis", "Chart Patterns", "Fibonacci", "Pivot Points"]
            ),
            cls(
                type=TimeFrameType.H6,
                interval_minutes=360,
                display_name="6 ساعت",
                display_name_en="6 Hours",
                priority=8,
                description="مناسب برای تحلیل‌های بلند مدت‌تر",
                typical_holding_period="12 ساعت - 3 روز",
                suitable_for=["سوئینگ ترید", "تحلیل ساختاری", "ترندهای قوی"],
                related_timeframes=["4h", "8h", "12h"],
                technical_indicators=["Long-term Trends", "Major Support/Resistance", "Volume Analysis"]
            ),
            cls(
                type=TimeFrameType.H8,
                interval_minutes=480,
                display_name="8 ساعت",
                display_name_en="8 Hours",
                priority=9,
                description="تحلیل ساختار بازار و ترندهای قوی",
                typical_holding_period="1-4 روز",
                suitable_for=["سوئینگ ترید", "تحلیل ساختاری", "ترند‌های اصلی"],
                related_timeframes=["6h", "12h", "1d"],
                technical_indicators=["Structural Analysis", "Major Trends", "Key Levels"]
            ),
            cls(
                type=TimeFrameType.H12,
                interval_minutes=720,
                display_name="12 ساعت",
                display_name_en="12 Hours",
                priority=10,
                description="تحلیل نیمه روزانه برای ترندهای قوی",
                typical_holding_period="1-7 روز",
                suitable_for=["سوئینگ ترید", "پوزیشن گیری", "ترندهای اصلی"],
                related_timeframes=["8h", "1d", "2d"],
                technical_indicators=["Major Trends", "Key Support/Resistance", "Long-term Patterns"]
            ),
            cls(
                type=TimeFrameType.D1,
                interval_minutes=1440,
                display_name="روزانه",
                display_name_en="Daily",
                priority=11,
                description="مهم‌ترین تایم فریم برای تحلیل بلند مدت",
                typical_holding_period="3-30 روز",
                suitable_for=["سوئینگ ترید", "پوزیشن ترید", "تحلیل بنیادی"],
                related_timeframes=["12h", "2d", "1w"],
                technical_indicators=["All Major Indicators", "Long-term Trends", "Fundamental Analysis"]
            ),
            cls(
                type=TimeFrameType.D2,
                interval_minutes=2880,
                display_name="2 روزه",
                display_name_en="2 Days",
                priority=12,
                description="کاهش نویز روزانه و تمرکز بر ترندهای قوی",
                typical_holding_period="1-6 هفته",
                suitable_for=["پوزیشن ترید", "سرمایه‌گذاری", "ترندهای قوی"],
                related_timeframes=["1d", "3d", "1w"],
                technical_indicators=["Long-term Trends", "Major Patterns", "Fundamental Levels"]
            ),
            cls(
                type=TimeFrameType.D3,
                interval_minutes=4320,
                display_name="3 روزه",
                display_name_en="3 Days",
                priority=13,
                description="تحلیل ترندهای متوسط تا بلند مدت",
                typical_holding_period="2-8 هفته",
                suitable_for=["پوزیشن ترید", "سرمایه‌گذاری", "ترند‌های اصلی"],
                related_timeframes=["2d", "5d", "1w"],
                technical_indicators=["Trend Analysis", "Major Support/Resistance", "Cycle Analysis"]
            ),
            cls(
                type=TimeFrameType.D5,
                interval_minutes=7200,
                display_name="5 روزه",
                display_name_en="5 Days",
                priority=14,
                description="تحلیل هفتگی برای ترندهای بلند مدت",
                typical_holding_period="1-3 ماه",
                suitable_for=["پوزیشن ترید", "سرمایه‌گذاری بلند مدت"],
                related_timeframes=["3d", "1w", "2w"],
                technical_indicators=["Weekly Trends", "Long-term Patterns", "Cycle Analysis"]
            ),
            cls(
                type=TimeFrameType.W1,
                interval_minutes=10080,
                display_name="هفتگی",
                display_name_en="Weekly",
                priority=15,
                description="تحلیل ساختار کلی بازار و ترندهای اصلی",
                typical_holding_period="1-6 ماه",
                suitable_for=["پوزیشن ترید", "سرمایه‌گذاری", "تحلیل کلان"],
                related_timeframes=["5d", "2w", "1M"],
                technical_indicators=["Major Trends", "Long-term Cycles", "Fundamental Analysis"]
            ),
            cls(
                type=TimeFrameType.W2,
                interval_minutes=20160,
                display_name="2 هفته‌ای",
                display_name_en="Bi-weekly",
                priority=16,
                description="تحلیل ترندهای بسیار بلند مدت",
                typical_holding_period="2-12 ماه",
                suitable_for=["سرمایه‌گذاری بلند مدت", "تحلیل کلان"],
                related_timeframes=["1w", "1M", "3M"],
                technical_indicators=["Super Trends", "Long-term Cycles", "Macro Analysis"]
            ),
            cls(
                type=TimeFrameType.MN1,
                interval_minutes=43200,
                display_name="ماهانه",
                display_name_en="Monthly",
                priority=17,
                description="تحلیل بلند مدت و سرمایه‌گذاری",
                typical_holding_period="6 ماه - 2 سال",
                suitable_for=["سرمایه‌گذاری بلند مدت", "تحلیل کلان اقتصادی"],
                related_timeframes=["2w", "3M"],
                technical_indicators=["Super Long-term Trends", "Economic Cycles", "Fundamental Analysis"]
            ),
            cls(
                type=TimeFrameType.MN3,
                interval_minutes=129600,
                display_name="3 ماهه",
                display_name_en="Quarterly",
                priority=18,
                description="تحلیل فصلی و بررسی چرخه‌های اقتصادی",
                typical_holding_period="1-5 سال",
                suitable_for=["سرمایه‌گذاری طولانی مدت", "تحلیل چرخه‌ای"],
                related_timeframes=["1M"],
                technical_indicators=["Economic Cycles", "Fundamental Analysis", "Macro Trends"]
            )
        ]
        
        return [tf for tf in timeframes if tf.is_active]
    
    @classmethod
    def get_by_type(cls, timeframe_type: TimeFrameType) -> Optional['TimeFrame']:
        """دریافت تایم فریم بر اساس نوع"""
        all_timeframes = cls.get_all_active()
        for tf in all_timeframes:
            if tf.type == timeframe_type:
                return tf
        return None
    
    @classmethod
    def get_by_category(cls, category: TimeFrameCategory) -> List['TimeFrame']:
        """دریافت تایم فریم‌ها بر اساس دسته‌بندی"""
        all_timeframes = cls.get_all_active()
        return [tf for tf in all_timeframes if tf.category == category]
    
    @classmethod
    def get_recommended(cls) -> List['TimeFrame']:
        """دریافت تایم فریم‌های توصیه شده"""
        all_timeframes = cls.get_all_active()
        return [tf for tf in all_timeframes if tf.config.is_recommended]
    
    @classmethod
    def get_for_trading_style(cls, style: str) -> List['TimeFrame']:
        """دریافت تایم فریم‌های مناسب برای سبک معاملاتی خاص"""
        all_timeframes = cls.get_all_active()
        return [tf for tf in all_timeframes if style in tf.suitable_for]
    
    def __str__(self) -> str:
        return f"{self.display_name} ({self.type.value})"
    
    def __repr__(self) -> str:
        return f"TimeFrame(type={self.type.value}, interval={self.interval_minutes}min, category={self.category.value})"



# models/user.py

from dataclasses import dataclass, field
from datetime import datetime, date, timedelta
from typing import Dict, Any, List, Optional, Set, Union
from enum import Enum
from decimal import Decimal
import uuid
from .base import BaseModel
from .timeframe import TimeFrameType

class UserRole(Enum):
    """نقش کاربر"""
    FREE = "free"
    PREMIUM = "premium"
    VIP = "vip"
    ADMIN = "admin"
    SUPER_ADMIN = "super_admin"

class UserStatus(Enum):
    """وضعیت کاربر"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"
    BANNED = "banned"
    PENDING_VERIFICATION = "pending_verification"

class NotificationType(Enum):
    """انواع اعلان"""
    SIGNAL = "signal"
    NEWS = "news"
    MARKET_UPDATE = "market_update"
    PROMOTION = "promotion"
    SYSTEM = "system"

class RiskLevel(Enum):
    """سطح ریسک"""
    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"
    EXPERT = "expert"

class TradingExperience(Enum):
    """تجربه معاملاتی"""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    PROFESSIONAL = "professional"

@dataclass
class UserLimits(BaseModel):
    """محدودیت‌های کاربر بر اساس نقش"""
    max_signals_per_day: int = 10
    max_signals_per_hour: int = 2
    max_watchlist_symbols: int = 20
    max_custom_alerts: int = 5
    access_to_premium_features: bool = False
    access_to_historical_data: bool = False
    priority_support: bool = False
    
    @classmethod
    def get_limits_by_role(cls, role: UserRole) -> 'UserLimits':
        """دریافت محدودیت‌ها بر اساس نقش کاربر"""
        limits_map = {
            UserRole.FREE: cls(
                max_signals_per_day=10,
                max_signals_per_hour=2,
                max_watchlist_symbols=10,
                max_custom_alerts=3,
                access_to_premium_features=False,
                access_to_historical_data=False,
                priority_support=False
            ),
            UserRole.PREMIUM: cls(
                max_signals_per_day=50,
                max_signals_per_hour=10,
                max_watchlist_symbols=50,
                max_custom_alerts=15,
                access_to_premium_features=True,
                access_to_historical_data=True,
                priority_support=False
            ),
            UserRole.VIP: cls(
                max_signals_per_day=200,
                max_signals_per_hour=25,
                max_watchlist_symbols=100,
                max_custom_alerts=50,
                access_to_premium_features=True,
                access_to_historical_data=True,
                priority_support=True
            ),
            UserRole.ADMIN: cls(
                max_signals_per_day=1000,
                max_signals_per_hour=100,
                max_watchlist_symbols=500,
                max_custom_alerts=100,
                access_to_premium_features=True,
                access_to_historical_data=True,
                priority_support=True
            ),
            UserRole.SUPER_ADMIN: cls(
                max_signals_per_day=-1,  # Unlimited
                max_signals_per_hour=-1,  # Unlimited
                max_watchlist_symbols=-1,  # Unlimited
                max_custom_alerts=-1,  # Unlimited
                access_to_premium_features=True,
                access_to_historical_data=True,
                priority_support=True
            )
        }
        return limits_map.get(role, cls())

@dataclass
class NotificationSettings(BaseModel):
    """تنظیمات اعلان‌ها"""
    enabled_types: Set[NotificationType] = field(default_factory=lambda: {NotificationType.SIGNAL})
    quiet_hours_start: Optional[str] = None  # Format: "HH:MM"
    quiet_hours_end: Optional[str] = None    # Format: "HH:MM"
    timezone: str = "UTC"
    sound_enabled: bool = True
    vibration_enabled: bool = True
    email_notifications: bool = False
    sms_notifications: bool = False
    max_notifications_per_hour: int = 10
    
    def is_quiet_time(self, current_time: datetime) -> bool:
        """بررسی اینکه آیا در زمان سکوت هستیم یا نه"""
        if not self.quiet_hours_start or not self.quiet_hours_end:
            return False
        
        start_hour, start_min = map(int, self.quiet_hours_start.split(':'))
        end_hour, end_min = map(int, self.quiet_hours_end.split(':'))
        
        current_hour = current_time.hour
        current_min = current_time.minute
        
        start_minutes = start_hour * 60 + start_min
        end_minutes = end_hour * 60 + end_min
        current_minutes = current_hour * 60 + current_min
        
        if start_minutes <= end_minutes:
            return start_minutes <= current_minutes <= end_minutes
        else:  # Crosses midnight
            return current_minutes >= start_minutes or current_minutes <= end_minutes

@dataclass
class TradingProfile(BaseModel):
    """پروفایل معاملاتی کاربر"""
    experience_level: TradingExperience = TradingExperience.BEGINNER
    risk_tolerance: RiskLevel = RiskLevel.MODERATE
    preferred_markets: Set[str] = field(default_factory=set)  # forex, crypto, stocks, commodities
    trading_capital: Optional[Decimal] = None
    max_risk_per_trade: float = 2.0  # Percentage
    preferred_trading_sessions: Set[str] = field(default_factory=set)  # london, new_york, tokyo, sydney
    investment_goals: List[str] = field(default_factory=list)  # income, growth, hedging
    
    def get_recommended_position_size(self, account_balance: Decimal, stop_loss_pips: int) -> Decimal:
        """محاسبه اندازه پوزیشن پیشنهادی"""
        if not self.trading_capital or stop_loss_pips <= 0:
            return Decimal('0')
        
        risk_amount = self.trading_capital * (Decimal(str(self.max_risk_per_trade)) / 100)
        # Simple position sizing calculation
        position_size = risk_amount / Decimal(str(stop_loss_pips))
        return position_size

@dataclass
class UserPreferences(BaseModel):
    """تنظیمات کاربر"""
    preferred_timeframes: Set[TimeFrameType] = field(default_factory=set)
    preferred_symbols: Set[str] = field(default_factory=set)
    watchlist: Set[str] = field(default_factory=set)
    blocked_symbols: Set[str] = field(default_factory=set)
    min_confidence_score: float = 70.0
    max_signals_per_timeframe: int = 5
    language: str = "fa"  # fa, en, ar
    theme: str = "dark"  # dark, light
    chart_style: str = "candlestick"  # candlestick, line, bar
    auto_follow_signals: bool = False
    show_educational_content: bool = True
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'UserPreferences':
        return cls(
            preferred_timeframes=set(TimeFrameType(tf) for tf in data.get('preferred_timeframes', [])),
            preferred_symbols=set(data.get('preferred_symbols', [])),
            watchlist=set(data.get('watchlist', [])),
            blocked_symbols=set(data.get('blocked_symbols', [])),
            min_confidence_score=data.get('min_confidence_score', 70.0),
            max_signals_per_timeframe=data.get('max_signals_per_timeframe', 5),
            language=data.get('language', 'fa'),
            theme=data.get('theme', 'dark'),
            chart_style=data.get('chart_style', 'candlestick'),
            auto_follow_signals=data.get('auto_follow_signals', False),
            show_educational_content=data.get('show_educational_content', True)
        )

@dataclass
class UserStatistics(BaseModel):
    """آمار کاربر"""
    total_signals_received: int = 0
    signals_followed: int = 0
    successful_trades: int = 0
    failed_trades: int = 0
    total_pnl: Decimal = field(default_factory=lambda: Decimal('0'))
    win_rate: float = 0.0
    average_holding_time: Optional[timedelta] = None
    favorite_symbols: List[str] = field(default_factory=list)
    most_active_timeframe: Optional[TimeFrameType] = None
    registration_date: Optional[datetime] = None
    last_profitable_trade: Optional[datetime] = None
    consecutive_wins: int = 0
    consecutive_losses: int = 0
    max_consecutive_wins: int = 0
    max_consecutive_losses: int = 0
    
    def calculate_win_rate(self) -> float:
        """محاسبه نرخ برد"""
        total_trades = self.successful_trades + self.failed_trades
        if total_trades == 0:
            return 0.0
        return (self.successful_trades / total_trades) * 100
    
    def update_statistics(self, trade_result: bool, pnl: Decimal):
        """به‌روزرسانی آمار پس از معامله"""
        if trade_result:
            self.successful_trades += 1
            self.consecutive_wins += 1
            self.consecutive_losses = 0
            self.max_consecutive_wins = max(self.max_consecutive_wins, self.consecutive_wins)
            self.last_profitable_trade = datetime.now()
        else:
            self.failed_trades += 1
            self.consecutive_losses += 1
            self.consecutive_wins = 0
            self.max_consecutive_losses = max(self.max_consecutive_losses, self.consecutive_losses)
        
        self.total_pnl += pnl
        self.win_rate = self.calculate_win_rate()

@dataclass
class UserSubscription(BaseModel):
    """اشتراک کاربر"""
    plan_id: str
    start_date: datetime
    end_date: datetime
    is_active: bool = True
    auto_renew: bool = False
    payment_method: Optional[str] = None
    last_payment_date: Optional[datetime] = None
    next_billing_date: Optional[datetime] = None
    
    def is_expired(self) -> bool:
        """بررسی انقضای اشتراک"""
        return datetime.now() > self.end_date
    
    def days_remaining(self) -> int:
        """روزهای باقی‌مانده از اشتراک"""
        if self.is_expired():
            return 0
        return (self.end_date - datetime.now()).days

@dataclass
class User(BaseModel):
    """مدل کاربر"""
    # Basic Information
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    telegram_id: str
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    
    # Status and Role
    role: UserRole = UserRole.FREE
    status: UserStatus = UserStatus.ACTIVE
    is_verified: bool = False
    
    # Preferences and Settings
    preferences: UserPreferences = field(default_factory=UserPreferences)
    notification_settings: NotificationSettings = field(default_factory=NotificationSettings)
    trading_profile: TradingProfile = field(default_factory=TradingProfile)
    
    # Statistics and Tracking
    statistics: UserStatistics = field(default_factory=UserStatistics)
    signals_received_today: int = 0
    signals_received_this_hour: int = 0
    last_activity: Optional[datetime] = None
    last_signal_time: Optional[datetime] = None
    
    # Subscription and Limits
    subscription: Optional[UserSubscription] = None
    limits: UserLimits = field(default_factory=UserLimits)
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    last_login: Optional[datetime] = None
    
    # Additional Fields
    referral_code: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    referred_by: Optional[str] = None
    notes: Optional[str] = None  # Admin notes
    
    def __post_init__(self):
        """تنظیمات پس از ایجاد کاربر"""
        self.limits = UserLimits.get_limits_by_role(self.role)
        if not self.statistics.registration_date:
            self.statistics.registration_date = self.created_at
    
    @property
    def display_name(self) -> str:
        """نام نمایشی کاربر"""
        if self.first_name and self.last_name:
            return f"{self.first_name} {self.last_name}"
        elif self.first_name:
            return self.first_name
        elif self.username:
            return f"@{self.username}"
        else:
            return f"User {self.telegram_id}"
    
    @property
    def full_name(self) -> str:
        """نام کامل کاربر"""
        parts = [self.first_name, self.last_name]
        return " ".join(filter(None, parts)) or "Unknown"
    
    def can_receive_signal(self) -> bool:
        """بررسی اینکه آیا کاربر می‌تواند سیگنال دریافت کند"""
        if self.status != UserStatus.ACTIVE:
            return False
        
        # Check daily limit
        if self.limits.max_signals_per_day != -1 and self.signals_received_today >= self.limits.max_signals_per_day:
            return False
        
        # Check hourly limit
        if self.limits.max_signals_per_hour != -1 and self.signals_received_this_hour >= self.limits.max_signals_per_hour:
            return False
        
        # Check subscription
        if self.subscription and self.subscription.is_expired():
            return False
        
        # Check quiet hours
        if self.notification_settings.is_quiet_time(datetime.now()):
            return False
        
        return True
    
    def increment_signal_count(self):
        """افزایش شمارنده سیگنال‌های دریافت شده"""
        self.signals_received_today += 1
        self.signals_received_this_hour += 1
        self.statistics.total_signals_received += 1
        self.last_signal_time = datetime.now()
        self.last_activity = datetime.now()
    
    def reset_daily_counters(self):
        """ریست کردن شمارنده‌های روزانه"""
        self.signals_received_today = 0
    
    def reset_hourly_counters(self):
        """ریست کردن شمارنده‌های ساعتی"""
        self.signals_received_this_hour = 0
    
    def upgrade_role(self, new_role: UserRole):
        """ارتقاء نقش کاربر"""
        self.role = new_role
        self.limits = UserLimits.get_limits_by_role(new_role)
        self.updated_at = datetime.now()
    
    def is_premium_user(self) -> bool:
        """بررسی اینکه آیا کاربر پریمیوم است"""
        return self.role in [UserRole.PREMIUM, UserRole.VIP, UserRole.ADMIN, UserRole.SUPER_ADMIN]
    
    def has_access_to_feature(self, feature: str) -> bool:
        """بررسی دسترسی به ویژگی خاص"""
        feature_access = {
            'premium_signals': self.limits.access_to_premium_features,
            'historical_data': self.limits.access_to_historical_data,
            'priority_support': self.limits.priority_support,
            'custom_alerts': True,  # All users can create custom alerts
            'export_data': self.is_premium_user(),
            'api_access': self.role in [UserRole.VIP, UserRole.ADMIN, UserRole.SUPER_ADMIN],
            'bulk_operations': self.role in [UserRole.ADMIN, UserRole.SUPER_ADMIN]
        }
        return feature_access.get(feature, False)
    
    def get_subscription_status(self) -> str:
        """دریافت وضعیت اشتراک"""
        if not self.subscription:
            return "no_subscription"
        elif self.subscription.is_expired():
            return "expired"
        elif self.subscription.days_remaining() <= 7:
            return "expiring_soon"
        else:
            return "active"
    
    def to_dict(self) -> Dict[str, Any]:
        """تبدیل به دیکشنری برای ذخیره در دیتابیس"""
        return {
            'id': self.id,
            'telegram_id': self.telegram_id,
            'username': self.username,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'email': self.email,
            'phone': self.phone,
            'role': self.role.value,
            'status': self.status.value,
            'is_verified': self.is_verified,
            'preferences': self.preferences.to_dict(),
            'notification_settings': self.notification_settings.to_dict(),
            'trading_profile': self.trading_profile.to_dict(),
            'statistics': self.statistics.to_dict(),
            'signals_received_today': self.signals_received_today,
            'signals_received_this_hour': self.signals_received_this_hour,
            'last_activity': self.last_activity.isoformat() if self.last_activity else None,
            'last_signal_time': self.last_signal_time.isoformat() if self.last_signal_time else None,
            'subscription': self.subscription.to_dict() if self.subscription else None,
            'limits': self.limits.to_dict(),
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'last_login': self.last_login.isoformat() if self.last_login else None,
            'referral_code': self.referral_code,
            'referred_by': self.referred_by,
            'notes': self.notes
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'User':
        """ایجاد از دیکشنری"""
        preferences = UserPreferences.from_dict(data.get('preferences', {}))
        notification_settings = NotificationSettings.from_dict(data.get('notification_settings', {}))
        trading_profile = TradingProfile.from_dict(data.get('trading_profile', {}))
        statistics = UserStatistics.from_dict(data.get('statistics', {}))
        
        subscription = None
        if data.get('subscription'):
            subscription = UserSubscription.from_dict(data['subscription'])
        
        limits = UserLimits.from_dict(data.get('limits', {}))
        
        return cls(
            id=data.get('id', str(uuid.uuid4())),
            telegram_id=data['telegram_id'],
            username=data.get('username'),
            first_name=data.get('first_name'),
            last_name=data.get('last_name'),
            email=data.get('email'),
            phone=data.get('phone'),
            role=UserRole(data.get('role', 'free')),
            status=UserStatus(data.get('status', 'active')),
            is_verified=data.get('is_verified', False),
            preferences=preferences,
            notification_settings=notification_settings,
            trading_profile=trading_profile,
            statistics=statistics,
            signals_received_today=data.get('signals_received_today', 0),
            signals_received_this_hour=data.get('signals_received_this_hour', 0),
            last_activity=datetime.fromisoformat(data['last_activity']) if data.get('last_activity') else None,
            last_signal_time=datetime.fromisoformat(data['last_signal_time']) if data.get('last_signal_time') else None,
            subscription=subscription,
            limits=limits,
            created_at=datetime.fromisoformat(data.get('created_at', datetime.now().isoformat())),
            updated_at=datetime.fromisoformat(data.get('updated_at', datetime.now().isoformat())),
            last_login=datetime.fromisoformat(data['last_login']) if data.get('last_login') else None,
            referral_code=data.get('referral_code', str(uuid.uuid4())[:8]),
            referred_by=data.get('referred_by'),
            notes=data.get('notes')
        )



======

indicator_management.py :

from logger_config import logger
import pandas as pd

from .candlestick_patterns import detect_all_candlestick_patterns
from .correlation import comprehensive_correlation_analysis, quick_correlation_check
from .fibonacci import calculate_fibonacci_levels
from .market_structure import analyze_market_structure
from .momentum_indicators import calculate_technical_indicators
from .moving_averages import calculate_moving_averages
from .support_resistance import calculate_pivot_points, calculate_support_resistance_levels
from .trend_indicators import (
    calculate_adx_internal, calculate_aroon, calculate_donchian_channels,
    calculate_supertrend, calculate_trend_strength
)
from .volatility_indicators import calculate_atr, calculate_bollinger_bands
from .volume_indicators import calculate_ad_line, calculate_chaikin_money_flow, calculate_obv, calculate_vwap


class IndicatorConfig:
    @staticmethod
    def calculate_indicators(df, config=None):
        """
        Calculate all available technical indicators on the given DataFrame
        
        Args:
            df (pd.DataFrame): DataFrame containing OHLCV data
            config (dict, optional): Configuration parameters for indicators
            
        Returns:
            dict: Dictionary containing indicators and trading signals
        """
        if df is None or df.empty:
            logger.error("DataFrame is None or empty")
            return {}
        
        # Default configuration
        default_config = {
            'use_btc_correlation': False,
            'btc_df': None,
            'ma_types': ['sma', 'ema', 'wma'],
            'sma_period': 20,
            'ema_period': 20,
            'wma_period': 20,
            'fibonacci_lookback': 50,
            'support_resistance_window': 20,
            'support_resistance_min_touches': 3,
            'trend_adx_period': 14,
            'volatility_bollinger_period': 20,
            'volatility_bollinger_std': 2,
            'volatility_atr_period': 14,
            'volume_cmf_period': 20,
            'market_structure_swing_strength': 5,
        }
        
        # Update default config with provided config
        if config:
            default_config.update(config)
        
        # Initialize results dictionary
        indicators = {}
        
        try:
            # Calculate moving averages
            logger.info("Calculating moving averages...")
            ma_results = calculate_moving_averages(
                df, 
                ma_types=default_config['ma_types'],
                sma_period=default_config['sma_period'],
                ema_period=default_config['ema_period'],
                wma_period=default_config['wma_period']
            )
            indicators.update(ma_results)
            
            # Calculate candlestick patterns
            logger.info("Detecting candlestick patterns...")
            candlestick_patterns = detect_all_candlestick_patterns(df)
            indicators['candlestick_patterns'] = candlestick_patterns
            
            # Calculate Fibonacci levels
            logger.info("Calculating Fibonacci levels...")
            fibonacci_levels = calculate_fibonacci_levels(df, default_config['fibonacci_lookback'])
            indicators['fibonacci_levels'] = fibonacci_levels
            
            # Calculate pivot points and support/resistance
            logger.info("Calculating support/resistance levels...")
            pivot_points = calculate_pivot_points(df)
            indicators['pivot_points'] = pivot_points
            
            support_resistance = calculate_support_resistance_levels(
                df, 
                window=default_config['support_resistance_window'],
                min_touches=default_config['support_resistance_min_touches']
            )
            indicators['support_resistance'] = support_resistance
            
            # Calculate trend indicators
            logger.info("Calculating trend indicators...")
            adx_results = calculate_adx_internal(df, default_config['trend_adx_period'])
            if adx_results:
                indicators.update(adx_results)
            
            aroon_results = calculate_aroon(df)
            if aroon_results:
                indicators.update(aroon_results)
            
            donchian_results = calculate_donchian_channels(df)
            if donchian_results:
                indicators.update(donchian_results)
            
            supertrend_results = calculate_supertrend(df)
            if supertrend_results:
                indicators['supertrend'] = supertrend_results
            
            trend_strength_results = calculate_trend_strength(df)
            if trend_strength_results:
                indicators['trend_strength'] = trend_strength_results
            
            # Calculate volatility indicators
            logger.info("Calculating volatility indicators...")
            atr = calculate_atr(df, default_config['volatility_atr_period'])
            indicators['atr'] = atr
            
            bollinger_results = calculate_bollinger_bands(
                df, 
                default_config['volatility_bollinger_period'], 
                default_config['volatility_bollinger_std']
            )
            if bollinger_results:
                indicators.update(bollinger_results)
            
            # Calculate volume indicators
            logger.info("Calculating volume indicators...")
            if 'volume' in df.columns:
                obv = calculate_obv(df)
                indicators['obv'] = obv
                
                ad_line = calculate_ad_line(df)
                indicators['ad_line'] = ad_line
                
                cmf = calculate_chaikin_money_flow(df, default_config['volume_cmf_period'])
                indicators['cmf'] = cmf
                
                vwap_results = calculate_vwap(df)
                if vwap_results:
                    indicators.update(vwap_results)
            
            # Calculate momentum indicators
            logger.info("Calculating momentum indicators...")
            momentum_indicators = calculate_technical_indicators(df)
            indicators.update(momentum_indicators)
            
            # Calculate market structure
            logger.info("Analyzing market structure...")
            market_structure = analyze_market_structure(
                df, 
                swing_strength=default_config['market_structure_swing_strength']
            )
            indicators['market_structure'] = market_structure
            
            # Calculate correlation if BTC data is provided
            if default_config['use_btc_correlation'] and default_config['btc_df'] is not None:
                logger.info("Calculating BTC correlation...")
                btc_correlation = quick_correlation_check(df, default_config['btc_df'])
                indicators['btc_correlation'] = btc_correlation
            
            # Process the results to create trading signals
            signals = IndicatorConfig._generate_trading_signals(indicators, df)
            
            # Log successful calculations
            logger.info(f"Successfully calculated {len(indicators)} indicator groups")
            
            return {
                'indicators': indicators,
                'timestamp': pd.Timestamp.now(),
                'signals': signals
            }
            
        except Exception as e:
            logger.error(f"Error in calculate_indicators: {e}")
            return {
                'indicators': indicators,
                'timestamp': pd.Timestamp.now(),
                'signals': {},
                'error': str(e)
            }

    @staticmethod
    def _generate_trading_signals(indicators, df):
        """
        Generate trading signals based on calculated indicators
        
        Args:
            indicators (dict): Dictionary of calculated indicators
            df (pd.DataFrame): Original price DataFrame
        
        Returns:
            dict: Trading signals with entry and exit points
        """
        signals = {
            'buy': [],
            'sell': [],
            'strength': 0,
            'entry_points': [],
            'exit_points': []
        }
        
        try:
            if not indicators or df.empty:
                return signals
            
            current_price = df['close'].iloc[-1]
            
            # Check moving averages crossovers
            if 'sma' in indicators and 'ema' in indicators:
                sma = indicators['sma']
                ema = indicators['ema']
                
                if not sma.empty and not ema.empty and len(sma) > 1 and len(ema) > 1:
                    # Bullish crossover: EMA crosses above SMA
                    if ema.iloc[-2] <= sma.iloc[-2] and ema.iloc[-1] > sma.iloc[-1]:
                        signals['buy'].append({
                            'indicator': 'ma_crossover',
                            'confidence': 70,
                            'entry': current_price,
                            'exit': current_price * 1.05
                        })
                    
                    # Bearish crossover: EMA crosses below SMA
                    if ema.iloc[-2] >= sma.iloc[-2] and ema.iloc[-1] < sma.iloc[-1]:
                        signals['sell'].append({
                            'indicator': 'ma_crossover',
                            'confidence': 70,
                            'entry': current_price,
                            'exit': current_price * 0.95
                        })
            
            # Check RSI for overbought/oversold conditions
            if 'rsi' in indicators:
                rsi = indicators['rsi']
                
                if not isinstance(rsi, pd.Series):
                    rsi = pd.Series(rsi)
                    
                if not rsi.empty and len(rsi) > 1:
                    # Oversold condition: RSI crosses above 30 from below
                    if rsi.iloc[-2] < 30 and rsi.iloc[-1] >= 30:
                        signals['buy'].append({
                            'indicator': 'rsi_oversold',
                            'confidence': 65,
                            'entry': current_price,
                            'exit': current_price * 1.04
                        })
                    
                    # Overbought condition: RSI crosses below 70 from above
                    if rsi.iloc[-2] > 70 and rsi.iloc[-1] <= 70:
                        signals['sell'].append({
                            'indicator': 'rsi_overbought',
                            'confidence': 65,
                            'entry': current_price,
                            'exit': current_price * 0.96
                        })
            
            # Check candlestick patterns
            if 'candlestick_patterns' in indicators:
                patterns = indicators['candlestick_patterns']
                
                # Bullish patterns
                bullish_patterns = ['bullish_engulfing', 'hammer', 'morning_star', 'piercing_line']
                for pattern in bullish_patterns:
                    if pattern in patterns and patterns[pattern].iloc[-1]:
                        signals['buy'].append({
                            'indicator': f'candlestick_{pattern}',
                            'confidence': 75 if pattern == 'morning_star' else 60,
                            'entry': current_price,
                            'exit': current_price * 1.03
                        })
                
                # Bearish patterns
                bearish_patterns = ['bearish_engulfing', 'shooting_star', 'evening_star', 'dark_cloud_cover']
                for pattern in bearish_patterns:
                    if pattern in patterns and patterns[pattern].iloc[-1]:
                        signals['sell'].append({
                            'indicator': f'candlestick_{pattern}',
                            'confidence': 75 if pattern == 'evening_star' else 60,
                            'entry': current_price,
                            'exit': current_price * 0.97
                        })
            
            # Calculate overall signal strength and determine best entry/exit points
            if signals['buy']:
                buy_confidence = [signal['confidence'] for signal in signals['buy']]
                max_confidence_idx = buy_confidence.index(max(buy_confidence))
                signals['strength'] = max(buy_confidence) / 100
                signals['entry_points'] = [signals['buy'][max_confidence_idx]['entry']]
                signals['exit_points'] = [signals['buy'][max_confidence_idx]['exit']]
            elif signals['sell']:
                sell_confidence = [signal['confidence'] for signal in signals['sell']]
                max_confidence_idx = sell_confidence.index(max(sell_confidence))
                signals['strength'] = -max(sell_confidence) / 100
                signals['entry_points'] = [signals['sell'][max_confidence_idx]['entry']]
                signals['exit_points'] = [signals['sell'][max_confidence_idx]['exit']]
            
        except Exception as e:
            logger.error(f"Error generating trading signals: {e}")
        
        return signals