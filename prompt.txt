file indicators.py :

analyzing market data, and managing trading strategies.

def safe_indicator_calculation(df, func, *args, **kwargs):

def calculate_fibonacci_levels(df, lookback=100):

def calculate_parabolic_sar(df, af=0.02, max_af=0.2):

def calculate_ichimoku(df):

def calculate_money_flow_index(df, period=14):

def calculate_commodity_channel_index(df, period=20):

def calculate_williams_r(df, period=14):

# اندیکاتورهای مومنتوم اضافی
def calculate_ultimate_oscillator(df, period1=7, period2=14, period3=28):

def calculate_rate_of_change(df, period=14):

def calculate_awesome_oscillator(df, fast_period=5, slow_period=34):

def calculate_trix(df, period=14):

def calculate_dpo(df, period=20):

def calculate_obv(df):

def calculate_accumulation_distribution(df):

def calculate_ad_line(df):

def calculate_chaikin_money_flow(df, period=20):

def calculate_volume_price_trend(df):

def calculate_ease_of_movement(df, period=14):

def calculate_average_true_range(df, period=14):

def calculate_atr(df, period=14):

def calculate_keltner_channels(df, period=20, multiplier=2):

def calculate_donchian_channels(df, period=20):

def calculate_standard_deviation(df, period=20):

def calculate_price_std(df, period=20):

def calculate_supertrend(df, period=10, multiplier=3.0):

def calculate_aroon_oscillator(df, period=14):

def calculate_aroon(df, period=14):

def calculate_adx(df, period=14):

def calculate_kama(df, period=10, fast_sc=2, slow_sc=30):

# الگوهای کندل استیک
def detect_hammer_doji_patterns(df):

def detect_engulfing_patterns(df):

def detect_star_patterns(df):

def detect_morning_evening_star(df):

# اندیکاتورهای مارکت استراکچر
def calculate_pivot_points(df):

def calculate_support_resistance(df, window=20):

def detect_market_structure_breaks(df, swing_strength=5):

def calculate_correlation_with_btc(df, btc_df, period=20):

def detect_market_regime(df, lookback=50):

def calculate_position_size_atr(capital, risk_percent, entry_price, atr_value, atr_multiplier=2):

def calculate_dynamic_stop_loss(df, entry_price, position_type='long', atr_multiplier=2):

def optimize_risk_reward_ratio(entry_price, target_price, stop_loss, min_ratio=2.0):

def ensemble_signal_scoring(signals_dict, weights=None):

def adaptive_threshold_calculator(df, indicator_values, percentile_low=20, percentile_high=80):

def calculate_market_microstructure(df, period=20):

def calculate_support_resistance_levels(df, window=20, min_touches=3):

def detect_dark_cloud_cover(df):

def detect_piercing_line(df):

def detect_harami_patterns(df):

def calculate_vwap(df):

def filter_false_signals(df, signal_data, min_volume_ratio=1.2, min_trend_strength=0.1):

def calculate_market_structure_score(df, lookback=20):

==

file main.py :

def calculate_indicators(df):

def check_signals(df, symbol):

def calculate_signal_strength(df, signal_type):

def calculate_signal_accuracy_score(df, signal_data, symbol):

async def analyze_market():

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:

async def analyze_market():

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:

async def show_symbols(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:

async def close_exchange():

def main() -> None:

if __name__ == '__main__':
    main()